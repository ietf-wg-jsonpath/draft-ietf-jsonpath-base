<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.15 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>

<rfc ipr="trust200902" docName="draft-normington-jsonpath-latest" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title>JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>

    <date year="2020"/>

    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSON Path defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="">


<t><spanx style="strong">This document is a work in progress and has not yet been published
as an Internet Draft.</spanx></t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>JSON Path, or rather JSONPath, was introduced by Stefan Goessner as a simple
form of XPath for JSON.
See his original article <xref target="Goessner"/>.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<section anchor="requirements-language" title="Requirements Language">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

</section>
<section anchor="abnf-syntax" title="ABNF Syntax">

<t>The syntax in this document conforms to ABNF as defined by <xref target="RFC5234"/>.</t>

<t>ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

</section>
</section>
<section anchor="json-path-syntax-and-semantics" title="JSON Path Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSON Path is a string which selects zero or more nodes of any JSON document.
A valid JSON Path conforms to the ABNF syntax defined by this document.</t>

<t>A JSON Path MUST be encoded using UTF-8. To parse a JSON Path according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>A JSON document is logically a tree of nodes with the document as the root
node of the tree.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>.
The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSON Path and a JSON document,
and produce
a possibly empty list of nodes of the JSON document which are selected by
the JSON Path or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSON Path SHOULD be detected before selection is attempted
since these errors do not depend on the JSON document.
Therefore, an implementation SHOULD take a JSON Path and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON document and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSON Path and a JSON document
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSON Path is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON document is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSON Path consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON document, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors.
This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSON Path is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSON Path to the input JSON document.</t>

<t>Each selector acts on its input list of nodes as follows.
For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer.
Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSON Path <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSON Path consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document.
So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSON Path selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = %x2E dot-child-name / ; .<dot-child-name>
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any object node.
It selects
no nodes from a node which is not an object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any object node.
It also selects all the elements of any array node.
It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Union Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A union child is a union element consisting of a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = union-child ; see below for more alternatives
union-child = %x22 *double-quoted %x22 / ; "string"
              %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                              ; case insensitive hex digit
]]></artwork></figure>

<t>Notes:
1. double-quoted strings follow JSON in <xref target="RFC8259"/>.
   Single-quoted strings follow an analogous pattern.
2. <spanx style="verb">HEXDIG</spanx> includes A-F and a-f.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the union child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>%x5C %x22</c>
      <c>U+0022</c>
      <c>%x5C %x27</c>
      <c>U+0027</c>
      <c>%x5C %x2F</c>
      <c>U+002F</c>
      <c>%x5C %x5C</c>
      <c>U+005C</c>
      <c>%x5C %x62</c>
      <c>U+0008</c>
      <c>%x5C %x66</c>
      <c>U+000C</c>
      <c>%x5C %x6E</c>
      <c>U+000A</c>
      <c>%x5C %x72</c>
      <c>U+000D</c>
      <c>%x5C %x74</c>
      <c>U+0009</c>
      <c>%x5C uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The union child selects the value corresponding to the key from any object
node with the key as a name.
It selects no nodes from a node which is not an object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector is a union element which selects zero or more elements
of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is a union element consisting of an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = ["-"] ("0" / (%x31-39 *%x30-39))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
DIGIT1 = %x31-39            ; non-zero digit
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice is a union element consisting of optional integers (in base 10) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ start ] ws ":" ws [ end ]
                   [ ws ":" ws [ step ] ]
start = integer
end = integer
step = integer
]]></artwork></figure>

<t>Note: the array slices <spanx style="verb">:</spanx> and <spanx style="verb">::</spanx> are both syntactically valid, as are <spanx style="verb">:2:2</spanx>, <spanx style="verb">2::2</spanx>, and <spanx style="verb">2:4:</spanx>.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>.
Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>This memo includes no request to IANA.</t>

<t>All drafts are required to have an IANA considerations section (see
<xref format="default" target="RFC5226">Guidelines for Writing an IANA Considerations Section in
RFCs</xref> for a guide).
If the draft does not require IANA to do
anything, the section contains an explicit statement that this is the
case (as above).
If there are no requirements for IANA, the section will
be removed during conversion into an RFC by the RFC Editor.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>
<section anchor="Alternatives" title="Alternatives">

<t>An analogous standard, JSON Pointer, is provided by <xref target="RFC6901"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC5226" target='https://www.rfc-editor.org/info/rfc5226'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'><organization /></author>
<date year='2008' month='May' />
<abstract><t>Many protocols make use of identifiers consisting of constants and other well-known values.  Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec).  To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority.  For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).</t><t>In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made.  If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role.  This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.</t><t>This document obsoletes RFC 2434.  This document specifies an Internet Best  Current Practices for the Internet Community, and requests discussion and  suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='RFC' value='5226'/>
<seriesInfo name='DOI' value='10.17487/RFC5226'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>


<reference anchor="Goessner" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath - XPath for JSON</title>
    <author >
      <organization>Stefan Gössner</organization>
    </author>
    <date year="2007" month="February"/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>D-28359 Bremen</city>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
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
E9B1v7WzKPB/lDAK/PcOuEks/hfRd77WS0kAAA==

-->

</rfc>

