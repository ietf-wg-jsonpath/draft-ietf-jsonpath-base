<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.15 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>

<rfc ipr="trust200902" docName="draft-normington-jsonpath-latest" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title>JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>

    <date year="2020"/>

    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSON Path defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="">


<t><spanx style="strong">This document is a work in progress and has not yet been published
as an Internet Draft.</spanx></t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>JSON Path, or rather JSONPath, was introduced by Stefan Goessner as a simple
form of XPath for JSON.
See his original article <xref target="Goessner"/>.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<section anchor="requirements-language" title="Requirements Language">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

</section>
<section anchor="abnf-syntax" title="ABNF Syntax">

<t>The syntax in this document conforms to ABNF as defined by <xref target="RFC5234"/>.</t>

<t>ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

</section>
</section>
<section anchor="json-path-syntax-and-semantics" title="JSON Path Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSON Path is a string which selects zero or more nodes of any JSON document.
A valid JSON Path conforms to the ABNF syntax defined by this document.</t>

<t>A JSON Path MUST be encoded using UTF-8. To parse a JSON Path according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>A JSON document is logically a tree of nodes with the document as the root
node of the tree.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>.
The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSON Path and a JSON document,
and produce
a possibly empty list of nodes of the JSON document which are selected by
the JSON Path or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSON Path SHOULD be detected before selection is attempted
since these errors do not depend on the JSON document.
Therefore, an implementation SHOULD take a JSON Path and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON document and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSON Path and a JSON document
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSON Path is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON document is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSON Path consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON document, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors.
This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSON Path is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSON Path to the input JSON document.</t>

<t>Each selector acts on its input list of nodes as follows.
For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer.
Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSON Path <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSON Path consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document.
So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSON Path selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = %x2E dot-child-name / ; .<dot-child-name>
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any object node.
It selects
no nodes from a node which is not an object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any object node.
It also selects all the elements of any array node.
It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Union Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A union child is a union element consisting of a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = union-child ; see below for more alternatives
union-child = %x22 *double-quoted %x22 / ; "string"
              %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
]]></artwork></figure>

<t>Note: double-quoted strings follow JSON in <xref target="RFC8259"/>.
Single-quoted strings follow an analogous pattern.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the union child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>%x5C %x22</c>
      <c>U+0022</c>
      <c>%x5C %x27</c>
      <c>U+0027</c>
      <c>%x5C %x2F</c>
      <c>U+002F</c>
      <c>%x5C %x5C</c>
      <c>U+005C</c>
      <c>%x5C %x62</c>
      <c>U+0008</c>
      <c>%x5C %x66</c>
      <c>U+000C</c>
      <c>%x5C %x6E</c>
      <c>U+000A</c>
      <c>%x5C %x72</c>
      <c>U+000D</c>
      <c>%x5C %x74</c>
      <c>U+0009</c>
      <c>%x5C uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The union child selects the value corresponding to the key from any object
node with the key as a name.
It selects no nodes from a node which is not an object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector is a union element which selects zero or more elements
of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is a union element consisting of an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = [%x2D] (%x30 / (%x31-39 *%x30-39))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice is a union element consisting of two or three integers (in
base 10 and which may be omitted) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ integer ] ws %x3A ws [ integer ]
                   [ ws %x3A ws [ integer ] ]
                            ; start:end or start:end:step
]]></artwork></figure>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>.
Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>This memo includes no request to IANA.</t>

<t>All drafts are required to have an IANA considerations section (see
<xref format="default" target="RFC5226">Guidelines for Writing an IANA Considerations Section in
RFCs</xref> for a guide).
If the draft does not require IANA to do
anything, the section contains an explicit statement that this is the
case (as above).
If there are no requirements for IANA, the section will
be removed during conversion into an RFC by the RFC Editor.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>
<section anchor="Alternatives" title="Alternatives">

<t>An analogous standard, JSON Pointer, is provided by <xref target="RFC6901"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC5226" target='https://www.rfc-editor.org/info/rfc5226'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'><organization /></author>
<date year='2008' month='May' />
<abstract><t>Many protocols make use of identifiers consisting of constants and other well-known values.  Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec).  To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority.  For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).</t><t>In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made.  If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role.  This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.</t><t>This document obsoletes RFC 2434.  This document specifies an Internet Best  Current Practices for the Internet Community, and requests discussion and  suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='RFC' value='5226'/>
<seriesInfo name='DOI' value='10.17487/RFC5226'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>


<reference anchor="Goessner" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath - XPath for JSON</title>
    <author >
      <organization>Stefan Gössner</organization>
    </author>
    <date year="2007" month="February"/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>D-28359 Bremen</city>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
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
38Eo8D8f4P6p+B8JE7DKZkgAAA==

-->

</rfc>

