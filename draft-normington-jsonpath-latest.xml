<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.15 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>

<rfc ipr="trust200902" docName="draft-normington-jsonpath-latest" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title>JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>

    <date year="2020"/>

    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSON Path defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="">


<t><spanx style="strong">This document is a work in progress and has not yet been published
as an Internet Draft.</spanx></t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>JSON Path, or rather JSONPath, was introduced by Stefan Goessner as a simple
form of XPath for JSON.
See his original article <xref target="Goessner"/>.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<section anchor="requirements-language" title="Requirements Language">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

</section>
<section anchor="abnf-syntax" title="ABNF Syntax">

<t>The syntax in this document conforms to ABNF as defined by <xref target="RFC5234"/>.</t>

<t>ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

</section>
</section>
<section anchor="json-path-syntax-and-semantics" title="JSON Path Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSON Path is a string which selects zero or more nodes of any JSON document.
A valid JSON Path conforms to the ABNF syntax defined by this document.</t>

<t>A JSON Path MUST be encoded using UTF-8. To parse a JSON Path according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>A JSON document is logically a tree of nodes with the document as the root
node of the tree.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>. The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSON Path and a JSON document,
and produce
a possibly empty list of nodes of the JSON document which are selected by
the JSON Path or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSON Path SHOULD be detected before selection is attempted
since these errors do not depend on the JSON document.
Therefore, an implementation SHOULD take a JSON Path and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON document and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSON Path and a JSON document
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSON Path is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON document is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSON Path consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON document, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors. This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSON Path is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSON Path to the input JSON document.</t>

<t>Each selector acts on its input list of nodes as follows. For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer. Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSON Path <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSON Path consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document. So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSON Path selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = %x2E dot-child-name / ; .<dot-child-name>
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any object node. It selects
no nodes from a node which is not an object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any object node.
It also selects all the elements of any array node. It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Union Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A union child is a union element consisting of a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = union-child ; see below for more alternatives
union-child = %x22 *double-quoted %x22 / ; "string"
              %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
]]></artwork></figure>

<t>Note: double-quoted strings follow JSON in <xref target="RFC8259"/>.
Single-quoted strings follow an analogous pattern.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the union child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>%x5C %x22</c>
      <c>U+0022</c>
      <c>%x5C %x27</c>
      <c>U+0027</c>
      <c>%x5C %x2F</c>
      <c>U+002F</c>
      <c>%x5C %x5C</c>
      <c>U+005C</c>
      <c>%x5C %x62</c>
      <c>U+0008</c>
      <c>%x5C %x66</c>
      <c>U+000C</c>
      <c>%x5C %x6E</c>
      <c>U+000A</c>
      <c>%x5C %x72</c>
      <c>U+000D</c>
      <c>%x5C %x74</c>
      <c>U+0009</c>
      <c>%x5C uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The union child selects the value corresponding to the key from any object
node with the key as a name.
It selects no nodes from a node which is not an object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector is a union element which selects zero or more elements
of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is a union element consisting of an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = [%x2D] (%x30 / (%x31-39 *%x30-39))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice is a union element consisting of two or three integers (in
base 10 and which may be omitted) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ integer ] ws %x3A ws [ integer ]
                   [ ws %x3A ws [ integer ] ]
                            ; start:end or start:end:step
]]></artwork></figure>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>. Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>This memo includes no request to IANA.</t>

<t>All drafts are required to have an IANA considerations section (see
<xref format="default" target="RFC5226">Guidelines for Writing an IANA Considerations Section in
RFCs</xref> for a guide).
If the draft does not require IANA to do
anything, the section contains an explicit statement that this is the
case (as above).
If there are no requirements for IANA, the section will
be removed during conversion into an RFC by the RFC Editor.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>
<section anchor="Alternatives" title="Alternatives">

<t>An analogous standard, JSON Pointer, is provided by <xref target="RFC6901"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC5226" target='https://www.rfc-editor.org/info/rfc5226'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'><organization /></author>
<date year='2008' month='May' />
<abstract><t>Many protocols make use of identifiers consisting of constants and other well-known values.  Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec).  To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority.  For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).</t><t>In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made.  If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role.  This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.</t><t>This document obsoletes RFC 2434.  This document specifies an Internet Best  Current Practices for the Internet Community, and requests discussion and  suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='RFC' value='5226'/>
<seriesInfo name='DOI' value='10.17487/RFC5226'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>


<reference anchor="Goessner" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath - XPath for JSON</title>
    <author >
      <organization>Stefan Gössner</organization>
    </author>
    <date year="2007" month="February"/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>D-28359 Bremen</city>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
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
A9wXFf8DW4BqEz5IAAA=

-->

</rfc>

