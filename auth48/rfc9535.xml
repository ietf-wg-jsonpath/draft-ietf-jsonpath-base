<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<!-- generated by https://github.com/cabo/kramdown-rfc version 1.6.43 (Ruby 3.2.2) -->

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-jsonpath-base-21" number="9535" submissionType="IETF" category="std" consensus="true" xml:lang="en" tocDepth="4" tocInclude="true" sortRefs="true" symRefs="true" updates="" obsoletes="" version="3">

  <!-- xml2rfc v2v3 conversion 3.18.0 -->
  <front>
    <title abbrev="JSONPath">JSONPath: Query Expressions for JSON</title>
    <seriesInfo name="RFC" value="9535"/>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner" role="editor">
      <organization>Fachhochschule Dortmund</organization>
      <address>
        <postal>
          <street>Sonnenstraße 96</street>
          <city>Dortmund</city>
          <code>D-44139</code>
          <country>Germany</country>
        </postal>
        <email>stefan.goessner@fh-dortmund.de</email>
      </address>
    </author>
    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization/>
      <address>
        <postal>
          <street/>
          <city>Winchester</city>
          <region/>
          <code/>
          <country>United Kingdom</country>
        </postal>
        <phone/>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann" role="editor">
      <organization>Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>
    <date year="2024" month="February"/>
    <area>art</area>
    <workgroup>jsonpath</workgroup>
    <keyword>JSON</keyword>
    <abstract>
<t>JSONPath defines a string syntax for selecting and extracting JSON (RFC 8259) values from within a given JSON value.</t>
    </abstract>
  </front>
  <middle>

<!-- use as {: unnumbered} -->

<!-- editorial issue: lots of complicated nesting of quotes, as in -->
<!-- `"13 == '13'"` or `$`.  We probably should find a simpler style -->

<section anchor="introduction">
      <name>Introduction</name>
      <t>JSON <xref target="RFC8259"/> is a popular representation
format for structured data values.
JSONPath defines a string syntax for selecting and extracting JSON values
from within a given JSON value.</t>
<t>In relation to JSON Pointer <xref target="RFC6901"/>, JSONPath is not intended as a replacement but as a more powerful
companion. See <xref target="json-pointer"/>.</t>
      <section anchor="terminology">
        <name>Terminology</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>	
<t>The grammatical rules in this document are to be interpreted as ABNF,
as described in <xref target="RFC5234"/>.
ABNF terminal values in this document define Unicode scalar values rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <tt>%x2318</tt>.</t>
        <t>Functions are referred to using the function name followed by a pair
of parentheses, as in <tt>fname()</tt>.</t>
        <t>The terminology of <xref target="RFC8259"/> applies except where clarified below.
The terms "primitive" and "structured" are used to group
different kinds of values as in <xref section="1" sectionFormat="of" target="RFC8259"/>. JSON objects and arrays are
structured; all other values are primitive.
Definitions for "object", "array", "number", and "string" remain
unchanged.
Importantly, "object" and "array" in particular do not take on a
generic meaning, such as they would in a general programming context.</t>
<t>The terminology of <xref target="RFC9485"/> applies.</t>
<t>Additional terms used in this document are defined below.</t>
        <dl>
          <dt>Value:</dt>
          <dd>
            <t>As per <xref target="RFC8259"/>, a data item conforming to the generic data model of JSON, i.e.,
primitive data (numbers, text strings, and the special
values null, true, and false), or structured data (JSON objects and arrays).
<xref target="RFC8259"/> focuses on the textual representation of JSON values and
does not fully define the value abstraction assumed here.</t>
          </dd>
          <dt>Member:</dt>
          <dd>
            <t>A name/value pair in an object.  (A member is not itself a value.)</t>
          </dd>
          <dt>Name:</dt>
          <dd>
            <t>The name (a string) in a name/value pair constituting a member.
This is also used in <xref target="RFC8259"/>, but that specification does not
formally define it.
It is included here for completeness.</t>
          </dd>
          <dt>Element:</dt>
          <dd>
            <t>A value in a JSON array.</t>
          </dd>
          <dt>Index:</dt>
          <dd>
            <t>An integer that identifies a specific element in an array.</t>
          </dd>
          <dt>Query:</dt>
          <dd>
            <t>Short name for a JSONPath expression.</t>
          </dd>
          <dt>Query Argument:</dt>
          <dd>
            <t>Short name for the value a JSONPath expression is applied to.
</t>
          </dd>
          <dt>Location:</dt>
          <dd>
            <t>The position of a value within the query argument. This can be thought of
as a sequence of names and indexes navigating to the value through
the objects and arrays in the query argument, with the empty sequence
indicating the query argument itself.
A location can be represented as a Normalized Path (defined below).</t>
          </dd>
          <dt>Node:</dt>
          <dd>
            <t>The pair of a value along with its location within the query argument.</t>
          </dd>
          <dt>Root Node:</dt>
          <dd>
            <t>The unique node whose value is the entire query argument.</t>
          </dd>
          <dt>Root Node Identifier:</dt>
          <dd>
            <t>The expression <tt>$</tt>, which refers to the root node of the query argument.</t>
          </dd>
          <dt>Current Node Identifier:</dt>
          <dd>
            <t>The expression <tt>@</tt>, which refers to the current node in the context
of the evaluation of a filter expression (described later).</t>
          </dd>
          <dt>Children (of a node):</dt>
          <dd>
            <t>If the node is an array, the nodes of its elements; if the node is an object, the nodes of its member values.
If the node is neither an array nor an object, it has no children.</t>
          </dd>
          <dt>Descendants (of a node):</dt>
          <dd>
            <t>The children of the node, together with the children of its children, and so forth
recursively. More formally, the "descendants" relation between nodes is the transitive
closure of the "children" relation.</t>
          </dd>
          <dt>Depth (of a descendant node within a value):</dt>
          <dd>
            <t>The number of ancestors of the node within the value. The root node of the value has depth zero,
the children of the root node have depth one, their children have depth two, and so forth.</t>
          </dd>
          <dt>Nodelist:</dt>
          <dd>
            <t>A list of nodes.
While a nodelist can be represented in JSON, e.g., as an array, this document
does not require or assume any particular representation.</t>
          </dd>
          <dt>Parameter:</dt>
          <dd>
            <t>Formal parameter (of a function) that can take a function argument
(an actual parameter) in a function expression.</t>
          </dd>
          <dt>Normalized Path:</dt>
          <dd>

            <t>A form of JSONPath expression that identifies a node in a value by
providing a query that results in exactly that node.  Each node in a
query argument is identified by exactly one Normalized Path (we say that the
Normalized Path is "unique" for that node), and to be a Normalized
Path for a specific query argument, the Normalized Path needs to identify
exactly one node. This is similar
to, but syntactically different from, a JSON Pointer <xref target="RFC6901"/>.
Note: This definition is based on the syntactical definition in <xref target="normalized-paths"/>;
JSONPath expressions that identify a node in a value but do not conform to that
syntax are not Normalized Paths.</t>
          </dd>
          <dt>Unicode Scalar Value:</dt>
          <dd>
            <t>Any Unicode <xref target="UNICODE"/> code point except high-surrogate and low-surrogate code points (in other words, integers in the inclusive base 16 ranges, either 0 to D7FF or
E000 to 10FFFF). JSONPath queries are sequences of Unicode scalar values.</t>
          </dd>
          <dt>Segment:</dt>
          <dd>
            <t>One of the constructs that selects children (<tt>[&lt;selectors&gt;]</tt>)
or descendants (<tt>..&wj;[&lt;selectors&gt;]</tt>) of an input value.</t>
          </dd>
          <dt>Selector:</dt>
          <dd>
            <t>A single item within a segment that takes the input value and produces a nodelist
consisting of child nodes of the input value.</t>
          </dd>
          <dt>Singular Query:</dt>
          <dd>
            <t>A JSONPath expression built from segments that have been syntactically restricted in
a certain way (<xref target="filter-selector-syntax"/>) so that, regardless of the input
value, the expression produces a nodelist containing at most one node.
Note: JSONPath expressions that always produce a singular nodelist but do not
conform to the syntax in <xref target="filter-selector-syntax"/> are not singular queries.</t>
          </dd>
        </dl>
        <section anchor="json-values-as-trees-of-nodes">
          <name>JSON Values as Trees of Nodes</name>

          <t>This document models the query argument as a tree of JSON values, each
with its own node.
A node is either the root node or one of its descendants.</t>
          <t>This document models the result of applying a query to the
query argument as a nodelist (a list of nodes).</t>
          <t>Nodes are the selectable parts of the query argument.
The only parts of an object that can be selected by a query are the
member values. Member names and members (name/value pairs) cannot be
selected.
Thus, member values have nodes, but members and member names do not.
Similarly, member values are children of an object, but members and
member names are not.</t>
        </section>
      </section>
      <section anchor="history">
        <name>History</name>
        <t>This document is based on <contact fullname="Stefan Gössner"/>'s popular JSONPath proposal (dated 2007-02-21) <xref target="JSONPath-orig"/>, builds on the experience from the widespread
deployment of its implementations, and provides a normative specification for it.</t>
        <t><xref target="inspired-by-xpath"/> describes how JSONPath was inspired by XML's XPath
<xref target="XPath"/>.</t>
        <t>JSONPath was intended as a lightweight companion to JSON
implementations in programming languages such as PHP and JavaScript,
so instead of defining its own expression language, like XPath did,
JSONPath delegated parts of a query to the underlying
runtime, e.g., JavaScript's <tt>eval()</tt> function.
As JSONPath was implemented in more environments, JSONPath
expressions became decreasingly portable.
For example, regular expression processing was often delegated to a
convenient regular expression engine.</t>
        <t>This document aims to remove such implementation-specific dependencies and
serve as a common JSONPath specification that can be used across
programming languages and environments.
This means that backwards compatibility is
not always achieved; a design principle of this document is to
go with a "consensus" between implementations even if it is rough, as
long as that does not jeopardize the objective of obtaining a usable,
stable JSON query language.</t>
        <t>The term <em>JSONPath</em> was chosen because of the XPath inspiration and also because
the outcome of a query consists of <em>paths</em> identifying nodes in the
JSON query argument.</t>
      </section>
      <section anchor="json-values">
        <name>JSON Values</name>
        <t>The JSON value a JSONPath query is applied to is, by definition, a
valid JSON value. A JSON value is often constructed by parsing
a JSON text.</t>
        <t>The parsing of a JSON text into a JSON value and what happens if a JSON
text does not represent valid JSON are not defined by this document.
Sections <xref target="RFC8259" section="4" sectionFormat="bare"/> and <xref target="RFC8259" section="8" sectionFormat="bare"/> of <xref target="RFC8259"/> identify specific situations that may
conform to the grammar for JSON texts but are not interoperable uses
of JSON, as they may cause unpredictable behavior.
This document does not attempt to define predictable
behavior for JSONPath queries in these situations.</t>
<t>Specifically, the "Semantics" subsections of Sections
<xref format="counter" target="name-selector"/>, <xref format="counter" target="wildcard-selector"/>,
<xref format="counter" target="filter-selector"/>, and <xref format="counter" target="descendant-segment"/> describe behavior that
becomes unpredictable when the JSON value for one of the objects
under consideration was constructed out of JSON text that exhibits
multiple members for a single object that share the same member name
("duplicate names"; see <xref section="4" sectionFormat="of" target="RFC8259"/>).
Also, when selecting a child by name (<xref target="name-selector"/>) and comparing strings
(<xref target="comparisons"/>), it is assumed these
strings are sequences of Unicode scalar values; the behavior becomes unpredictable
if they are not (<xref section="8.2" sectionFormat="of" target="RFC8259"/>).</t>
      </section>
      <section anchor="overview">
        <name>Overview of JSONPath Expressions</name>
        <t>A JSONPath expression is applied to a JSON value, known as the query argument.
The output is a nodelist.</t>
        <t>A JSONPath expression consists of an identifier followed by a series
of zero or more segments, each of which contains one or more selectors.</t>
        <section anchor="ids">
          <name>Identifiers</name>
          <t>The root node identifier <tt>$</tt> refers to the root node of the query argument,
i.e., to the argument as a whole.</t>
          <t>The current node identifier <tt>@</tt> refers to the current node in the context
of the evaluation of a filter expression (<xref target="filter-selector"/>).</t>
        </section>
        <section anchor="segments">
          <name>Segments</name>
          <t>Segments select children (<tt>[&lt;selectors&gt;]</tt>) or descendants (<tt>..&wj;[&lt;selectors&gt;]</tt>) of an input value.</t>
          <t>Segments can use <em>bracket notation</em>, for example:</t>
          <sourcecode type="application/jsonpath"><![CDATA[
$['store']['book'][0]['title']
]]></sourcecode>
          <t>or the more compact <em>dot notation</em>, for example:</t>
          <sourcecode type="application/jsonpath"><![CDATA[
$.store.book[0].title
]]></sourcecode>
          <t>Bracket notation contains one or more (comma-separated) selectors of any kind.
Selectors are detailed in the next section.</t>
          <t>A JSONPath expression may use a combination of bracket and dot notations.</t>
          <t>This document treats the bracket notations as canonical and defines the shorthand dot notation in terms
of bracket notation. Examples and descriptions use shorthand where convenient.</t>
        </section>
        <section anchor="selectors">
          <name>Selectors</name>
          <t>A name selector, e.g., <tt>'name'</tt>, selects a named child of an object.</t>
          <t>An index selector, e.g., <tt>3</tt>, selects an indexed child of an array.</t>
          <t>In the expression <tt>[*]</tt>, a wildcard <tt>*</tt> (<xref target="wildcard-selector"/>) selects all children of a
node, and in the expression <tt>..[*]</tt>, it selects all descendants of a node.</t>
          <t>An array slice <tt>start:end:step</tt> (<xref target="slice"/>) selects a series of
elements from an array, giving a start position, an end position, and
an optional step value that moves the position from the start to the
	  end.</t>
          <t>A filter expression <tt>?&lt;logical-expr&gt;</tt> selects certain children of an object or array, as in:</t>
          <sourcecode type="application/jsonpath"><![CDATA[
$.store.book[?@.price < 10].title
]]></sourcecode>
        </section>
        <section anchor="summary">
          <name>Summary</name>
          <t><xref target="tbl-overview"/> provides a brief overview of JSONPath syntax.</t>
	  <table anchor="tbl-overview">
            <name>Overview of JSONPath Syntax</name>
            <thead>
              <tr>
                <th align="left">Syntax Element</th>
                <th align="left">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">
                  <tt>$</tt></td>
                <td align="left">
                  <xref target="root-identifier">root node identifier</xref></td>
              </tr>
              <tr>
                <td align="left">
                  <tt>@</tt></td>
                <td align="left">
                  <xref target="filter-selector">current node identifier</xref> (valid only within filter selectors)</td>
              </tr>
              <tr>
                <td align="left">
                  <tt>[&lt;selectors&gt;]</tt></td>
                <td align="left">
                  <xref target="child-segment">child segment</xref>: selects zero or more children of a node</td>
              </tr>
              <tr>
                <td align="left">
                  <tt>.name</tt></td>
                <td align="left">shorthand for <tt>['name']</tt></td>
              </tr>
              <tr>
                <td align="left">
                  <tt>.*</tt></td>
                <td align="left">shorthand for <tt>[*]</tt></td>
              </tr>
              <tr>
                <td align="left">
                  <tt>..&wj;[&lt;selectors&gt;]</tt></td>
                <td align="left">
                  <xref target="descendant-segment">descendant segment</xref>: selects zero or more descendants of a node</td>
              </tr>
              <tr>
                <td align="left">
                  <tt>..name</tt></td>
                <td align="left">shorthand for <tt>..['name']</tt></td>
              </tr>
              <tr>
                <td align="left">
                  <tt>..*</tt></td>
                <td align="left">shorthand for <tt>..[*]</tt></td>
              </tr>
              <tr>
                <td align="left">
                  <tt>'name'</tt></td>
                <td align="left">
                  <xref target="name-selector">name selector</xref>: selects a named child of an object</td>
              </tr>
              <tr>
                <td align="left">
                  <tt>*</tt></td>
                <td align="left">
                  <xref target="wildcard-selector">wildcard selector</xref>: selects all children of a node</td>
              </tr>
              <tr>
                <td align="left">
                  <tt>3</tt></td>
                <td align="left">
                  <xref target="index-selector">index selector</xref>: selects an indexed child of an array (from 0)</td>
              </tr>
              <tr>
                <td align="left">
                  <tt>0:100:5</tt></td>
                <td align="left">
                  <xref target="slice">array slice selector</xref>: start:end:step for arrays</td>
              </tr>
              <tr>
                <td align="left">
                  <tt>?&lt;logical-expr&gt;</tt></td>
                <td align="left">
                  <xref target="filter-selector">filter selector</xref>: selects particular children using a logical expression</td>
              </tr>
              <tr>
                <td align="left">
                  <tt>length(@.foo)</tt></td>
                <td align="left">
                  <xref target="fnex">function extension</xref>: invokes a function in a filter expression</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="jsonpath-examples">
        <name>JSONPath Examples</name>
        <t>This section is informative. It provides examples of JSONPath expressions.</t>
        <t>The examples are based on the simple JSON value shown in
<xref target="fig-example-value"/>, representing a bookstore (which also has a bicycle).</t>
        <figure anchor="fig-example-value">
          <name>Example JSON Value</name>
          <sourcecode type="json"><![CDATA[
{ "store": {
    "book": [
      { "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      { "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      { "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      { "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 399
    }
  }
}
]]></sourcecode>
        </figure>
        <t><xref target="tbl-example"/> shows some JSONPath queries that might be applied to this example and their intended results.</t>
        <table anchor="tbl-example">
          <name>Example JSONPath Expressions and Their Intended Results When Applied to the Example JSON Value</name>
          <thead>
            <tr>
              <th align="left">JSONPath</th>
              <th align="left">Intended Result</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">
                <tt>$.store.book[*].author</tt></td>
              <td align="left">the authors of all books in the store</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$..author</tt></td>
              <td align="left">all authors</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$.store.*</tt></td>
              <td align="left">all things in the store, which are some books and a red bicycle</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$.store..price</tt></td>
              <td align="left">the prices of everything in the store</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$..book[2]</tt></td>
              <td align="left">the third book</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$..book[2].author</tt></td>
              <td align="left">the third book's author</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$..book[2].publisher</tt></td>
              <td align="left">empty result: the third book does not have a "publisher" member</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$..book[-1]</tt></td>
              <td align="left">the last book in order</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$..book[0,1]</tt><br/><tt>$..book[:2]</tt></td>
              <td align="left">the first two books</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$..book[?@.isbn]</tt></td>
              <td align="left">all books with an ISBN number</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$..book[?@.price&lt;10]</tt></td>
              <td align="left">all books cheaper than 10</td>
            </tr>
            <tr>
              <td align="left">
                <tt>$..*</tt></td>
              <td align="left">all member values and array elements contained in the input value</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="jsonpath-syntax-and-semantics">
      <name>JSONPath Syntax and Semantics</name>
      <section anchor="synsem-overview">
        <name>Overview</name>
        <t>A JSONPath <em>expression</em> is a string that, when applied to a JSON value
(the <em>query argument</em>), selects zero or more nodes of the argument and outputs
these nodes as a nodelist.</t>
        <t>A query <bcp14>MUST</bcp14> be encoded using UTF-8.
The grammar for queries given in this document assumes that its UTF-8 form is first decoded into
Unicode scalar values as described
in <xref target="RFC3629"/>; implementation approaches that lead to an equivalent
result are possible.</t>

<t>A string to be used as a JSONPath query needs to be <em>well-formed</em> and
<em>valid</em>.
A string is a well-formed JSONPath query if it conforms to the ABNF syntax in this document.
A well-formed JSONPath query is valid if it also fulfills both semantic
requirements posed by this document, which are as follows:</t>
        <ol spacing="normal" type="1"><li>Integer numbers in the JSONPath query that are relevant
to the JSONPath processing (e.g., index values and steps) <bcp14>MUST</bcp14> be
within the range of exact integer values defined in Internet JSON (I-JSON) (see <xref section="2.2" sectionFormat="of" target="RFC7493"/>), namely within the interval [-(2<sup>53</sup>)+1,
(2<sup>53</sup>)-1].</li>
          <li>Uses of function extensions <bcp14>MUST</bcp14> be <em>well-typed</em>,
as described in <xref target="well-typedness"/>.</li>
        </ol>
        <t>A JSONPath implementation <bcp14>MUST</bcp14> raise an error for any query that is not
well-formed and valid.
The well-formedness and the validity of JSONPath queries are independent of
the JSON value the query is applied to. No further errors relating to the
well-formedness and the validity of a JSONPath query can be
raised during application of the query to a value.
This clearly separates well-formedness/validity errors in the query
from mismatches that may actually stem from flaws in the data.</t>
        <t>Mismatches between the structure expected by a valid query
and the structure found in the data can lead to empty query results,
which may be unexpected and indicate bugs in either.
JSONPath implementations might therefore want to provide diagnostics
to the application developer that aid in finding the cause of empty
results.</t>
        <t>Obviously, an implementation can still fail when executing a JSONPath
query, e.g., because of resource depletion, but this is not modeled in
this document.  However, the implementation <bcp14>MUST NOT</bcp14>
silently malfunction.  Specifically, if a valid JSONPath query is
evaluated against a structured value whose size is too large to
process the query correctly (for instance, requiring the processing of
numbers that fall outside the range of exact values), the implementation
	<bcp14>MUST</bcp14> provide an indication of overflow.</t>
        <t>(Readers familiar with the HTTP error model may be reminded of 400
type errors when pondering well-formedness and validity, and they may
recognize resource depletion and related errors as comparable to 500 type
errors.)</t>
        <section anchor="syntax">
          <name>Syntax</name>
          <t>Syntactically, a JSONPath query consists of a root identifier (<tt>$</tt>), which
stands for a nodelist that contains the root node of the query argument,
followed by a possibly empty sequence of <em>segments</em>.</t>
          <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
jsonpath-query      = root-identifier segments
segments            = *(S segment)

B                   = %x20 /    ; Space
                      %x09 /    ; Horizontal tab
                      %x0A /    ; Line feed or New line
                      %x0D      ; Carriage return
S                   = *B        ; optional blank space
]]></sourcecode>
          <t>The syntax and semantics of segments are defined in <xref target="segments-details"/>.</t>
        </section>
        <section anchor="semantics">
          <name>Semantics</name>
          <t>In this document, the semantics of a JSONPath query define the
required results and do not prescribe the internal workings of an
implementation.  This document may describe semantics in a procedural
step-by-step fashion; however, such descriptions are normative only in the sense that any implementation <bcp14>MUST</bcp14> produce an identical result but not in the sense that implementers are required to use the same algorithms.</t>
          <t>The semantics are that a valid query is executed against a value
(the <em>query argument</em>) and produces a nodelist (i.e., a list of zero or more nodes of the value).</t>
          <t>The query is a root identifier followed by a sequence of zero or more segments, each of
which is applied to the result of the previous root identifier or segment and provides
input to the next segment.
These results and inputs take the form of nodelists.</t>
          <t>The nodelist resulting from the root identifier contains a single node
(the query argument).
The nodelist resulting from the last segment is presented as the
result of the query. Depending on the specific API, it might be
presented as an array of the JSON values at the nodes, an array of
Normalized Paths referencing the nodes, or both -- or some other
representation as desired by the implementation.
Note: An empty nodelist is a valid query result.</t>
          <t>A segment operates on each of the nodes in its input nodelist in turn,
and the resultant nodelists are concatenated in the order of the input
nodelist they were derived from to produce
the result of the segment. A node may be selected more than once and
appears that number of times in the nodelist. Duplicate nodes are not removed.</t>
          <t>A syntactically valid segment <bcp14>MUST NOT</bcp14> produce errors when executing the query.
This means that some
operations that might be considered erroneous, such as using an index
lying outside the range of an array,
simply result in fewer nodes being selected.
(Additional discussion of this property can be found in the introduction of <xref target="synsem-overview"/>.)</t>
          <t>As a consequence of this approach, if any of the segments
          produces an empty nodelist, then the whole query produces an empty
          nodelist.
	  </t>
          <t>If the semantics of a query give an implementation a choice of producing multiple possible orderings, a particular implementation
may produce distinct orderings in successive runs of the query.</t>
        </section>
        <section anchor="example">
          <name>Example</name>
          <t>Consider this example. With the query argument <tt>{"a":[{"b":0},{"b":1},{"c":2}]}</tt>, the
query <tt>$.a[*].b</tt> selects the following list of nodes (denoted here by their values): <tt>0</tt>, <tt>1</tt>.</t>
          <t>The query consists of <tt>$</tt> followed by three segments: <tt>.a</tt>, <tt>[*]</tt>, and <tt>.b</tt>.</t>
          <t>First, <tt>$</tt> produces a nodelist consisting of just the query argument.</t>
          <t>Next, <tt>.a</tt> selects from any object input node and selects the
node of any
member value of the input
node corresponding to the member name <tt>"a"</tt>.
The result is again a list containing a single node: <tt>[{"b":0},{"b":1},{"c":2}]</tt>.</t>
          <t>Next, <tt>[*]</tt> selects all the elements
from the input array node.
The result is a list of three nodes: <tt>{"b":0}</tt>, <tt>{"b":1}</tt>, and <tt>{"c":2}</tt>.</t>
          <t>Finally, <tt>.b</tt> selects from any object input node with a member name
<tt>b</tt> and selects the node of the member value of the input node corresponding to that name.
The result is a list containing <tt>0</tt>, <tt>1</tt>.
This is the concatenation of three lists: two of length one containing
<tt>0</tt>, <tt>1</tt>, respectively, and one of length zero.</t>
        </section>
      </section>
      <section anchor="root-identifier">
        <name>Root Identifier</name>
        <section anchor="syntax-1">
          <name>Syntax</name>
          <t>Every JSONPath query (except those inside filter expressions; see <xref target="filter-selector"/>) <bcp14>MUST</bcp14> begin with the root identifier <tt>$</tt>.</t>
          <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
root-identifier     = "$"
]]></sourcecode>
        </section>
        <section anchor="semantics-1">
          <name>Semantics</name>
          <t>The root identifier <tt>$</tt> represents the root node of the query argument
and produces a nodelist consisting of that root node.</t>
        </section>
        <section anchor="examples">
          <name>Examples</name>
          <aside>
            <t>Note: In this example and the following examples in Sections <xref format="counter" target="root-identifier"/> and
<xref format="counter" target="selector-details"/>, except for <xref target="tbl-comparison"/>, we will present a
JSON text to show the JSON value used as the query argument to the
queries in the examples and then a table with the following columns:</t>
            <ul spacing="normal">
              <li>Query: an example query to be applied to the query argument</li>
              <li>Result: the query result as a list of JSON values that were located in the query argument</li>
              <li>Result Path: the query result as a list of (normalized) paths into
the query argument, giving locations of the JSON values in the previous column</li>
              <li>Comment: descriptive information</li>
            </ul>
          </aside>
          <t>JSON:</t>
          <sourcecode type="json"><![CDATA[
{"k": "v"}
]]></sourcecode>
          <t>Queries:</t>
          <table anchor="tbl-root">
            <name>Root Identifier Example</name>
            <thead>
              <tr>
                <th align="center">Query</th>
                <th align="left">Result</th>
                <th align="center">Result Path</th>
                <th align="left">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">
                  <tt>$</tt></td>
                <td align="left">
                  <tt>{"k": "v"}</tt></td>
                <td align="center">
                  <tt>$</tt></td>
                <td align="left">Root node</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="selector-details">
        <name>Selectors</name>
        <t>Selectors appear only inside <xref target="child-segment">child segments</xref> and
<xref target="descendant-segment">descendant segments</xref>.</t>
        <t>A selector produces a nodelist consisting of zero or more children of the input value.</t>
        <t>There are various kinds of selectors that produce children of objects, children of arrays,
or children of either objects or arrays.</t>
        <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
selector            = name-selector /
                      wildcard-selector /
                      slice-selector /
                      index-selector /
                      filter-selector
]]></sourcecode>
        <t>The syntax and semantics of each kind of selector are defined below.</t>
        <section anchor="name-selector">
          <name>Name Selector</name>
          <section anchor="syntax-name">
            <name>Syntax</name>
            <t>A name selector <tt>'&lt;name&gt;'</tt> selects at most one object member value.</t>
            <t>In contrast to JSON,
the JSONPath syntax allows strings to be enclosed in <em>single</em> or <em>double</em> quotes.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
name-selector       = string-literal

string-literal      = %x22 *double-quoted %x22 /     ; "string"
                      %x27 *single-quoted %x27       ; 'string'

double-quoted       = unescaped /
                      %x27      /                    ; '
                      ESC %x22  /                    ; \"
                      ESC escapable

single-quoted       = unescaped /
                      %x22      /                    ; "
                      ESC %x27  /                    ; \'
                      ESC escapable

ESC                 = %x5C                           ; \ backslash

unescaped           = %x20-21 /                      ; see RFC 8259
                         ; omit 0x22 "
                      %x23-26 /
                         ; omit 0x27 '
                      %x28-5B /
                         ; omit 0x5C \
                      %x5D-D7FF /
                         ; skip surrogate code points
                      %xE000-10FFFF

escapable           = %x62 / ; b BS backspace U+0008
                      %x66 / ; f FF form feed U+000C
                      %x6E / ; n LF line feed U+000A
                      %x72 / ; r CR carriage return U+000D
                      %x74 / ; t HT horizontal tab U+0009
                      "/"  / ; / slash (solidus) U+002F
                      "\"  / ; \ backslash (reverse solidus) U+005C
                      (%x75 hexchar) ;  uXXXX U+XXXX

hexchar             = non-surrogate /
                      (high-surrogate "\" %x75 low-surrogate)
non-surrogate       = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG) /
                      ("D" %x30-37 2HEXDIG )
high-surrogate      = "D" ("8"/"9"/"A"/"B") 2HEXDIG
low-surrogate       = "D" ("C"/"D"/"E"/"F") 2HEXDIG

HEXDIG              = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
]]></sourcecode>
            <t>Notes:</t>
            <ul spacing="normal">
              <li>
                <tt>Double-quoted</tt> strings follow the JSON string syntax (<xref section="7" sectionFormat="of" target="RFC8259"/>);
		<tt>single-quoted</tt> strings follow an analogous pattern.
No attempt was made to improve on this syntax, so if it is desired to
escape characters with
scalar values above 0xFFFF, such as <u format="num-lit-name">🎼</u>,
they need to be represented
by a pair of surrogate escapes (<tt>"\uD83C\uDFBC"</tt> in this case).</li>
              <li>Alphabetic characters in quoted strings are case-insensitive in ABNF,
so each of the hexadecimal digits within <tt>\u</tt> escapes (as specified in rules
referenced by <tt>hexchar</tt>) can be either lowercase or uppercase,
while the <tt>u</tt> in <tt>\u</tt> needs to be lowercase (indicated as <tt>%x75</tt>).</li>
            </ul>
          </section>
          <section anchor="semantics-2">
            <name>Semantics</name>
            <t>A <tt>name-selector</tt> string <bcp14>MUST</bcp14> be converted to a
member name <tt>M</tt> by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
shown in <xref target="tbl-esc"/>:</t>
            <table anchor="tbl-esc">
              <name>Escape Sequence Replacements</name>
              <thead>
                <tr>
                  <th align="center">Escape Sequence</th>
                  <th align="center">Unicode Character</th>
                  <th align="left">Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">
                    <tt>\b</tt></td>
                  <td align="center">U+0008</td>
                  <td align="left">BS backspace</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>\t</tt></td>
                  <td align="center">U+0009</td>
                  <td align="left">HT horizontal tab</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>\n</tt></td>
                  <td align="center">U+000A</td>
                  <td align="left">LF line feed</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>\f</tt></td>
                  <td align="center">U+000C</td>
                  <td align="left">FF form feed</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>\r</tt></td>
                  <td align="center">U+000D</td>
                  <td align="left">CR carriage return</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>\"</tt></td>
                  <td align="center">U+0022</td>
                  <td align="left">quotation mark</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>\'</tt></td>
                  <td align="center">U+0027</td>
                  <td align="left">apostrophe</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>\/</tt></td>
                  <td align="center">U+002F</td>
                  <td align="left">slash (solidus)</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>\\</tt></td>
                  <td align="center">U+005C</td>
                  <td align="left">backslash (reverse solidus)</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>\uXXXX</tt></td>
                  <td align="center">see <xref target="syntax-name"/></td>
                  <td align="left">hexadecimal escape</td>
                </tr>
              </tbody>
            </table>
            <t>Applying the <tt>name-selector</tt> to an object node
selects a member value whose name equals the member name <tt>M</tt>
or selects nothing if there is no such member value.
Nothing is selected from a value that is not an object.</t>
            <t>Note: Processing the name selector requires comparing the member name string <tt>M</tt>
with member name strings in the JSON to which the selector is being applied.
Two strings <bcp14>MUST</bcp14> be considered equal if and only if they are identical
sequences of Unicode scalar values. In other words, normalization operations
<bcp14>MUST NOT</bcp14> be applied to either the member name string <tt>M</tt> from the JSONPath or
the member name strings in the JSON prior to comparison.</t>
          </section>
          <section anchor="examples-1">
            <name>Examples</name>
<t>JSON:</t>
            <sourcecode type="json"><![CDATA[
{
  "o": {"j j": {"k.k": 3}},
  "'": {"@": 2}
}
]]></sourcecode>
            <t>Queries:</t>
            <t>The examples in <xref target="tbl-name"/> show the name selector in use by child segments.</t>
            <table anchor="tbl-name">
              <name>Name Selector Examples</name>
              <thead>
                <tr>
                  <th align="center">Query</th>
                  <th align="left">Result</th>
                  <th align="center">Result Paths</th>
                  <th align="left">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">
                    <tt>$.o['j j']</tt></td>
                  <td align="left">
                    <tt>{"k.k": 3}</tt></td>
                  <td align="center">
                    <tt>$['o']['j j']</tt></td>
                  <td align="left">Named <br/>value in <br/>a nested <br/>object</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o['j&nbsp;j']&wj;['k.k']</tt></td>
                  <td align="left">
                    <tt>3</tt></td>
                  <td align="center">
                    <tt>$['o']['j&nbsp;j']&wj;['k.k']</tt></td>
                  <td align="left">Nesting <br/>further <br/>down</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o["j&nbsp;j"]&wj;["k.k"]</tt></td>
                  <td align="left">
                    <tt>3</tt></td>
                  <td align="center">
                    <tt>$['o']['j&nbsp;j']&wj;['k.k']</tt></td>
                  <td align="left">Different <br/>delimiter <br/>in the query, <br/>unchanged <br/>Normalized <br/>Path</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$["'"]["@"]</tt></td>
                  <td align="left">
                    <tt>2</tt></td>
                  <td align="center">
                    <tt>$['\'']['@']</tt></td>
                  <td align="left">Unusual <br/>member <br/>names</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>
        <section anchor="wildcard-selector">
          <name>Wildcard Selector</name>
          <section anchor="syntax-2">
            <name>Syntax</name>
            <t>The wildcard selector consists of an asterisk.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
wildcard-selector   = "*"
]]></sourcecode>
          </section>
          <section anchor="semantics-3">
            <name>Semantics</name>
            <t>A wildcard selector selects the nodes of all children of an object or array.
The order in which the children of an object appear in the resultant nodelist is not stipulated,
since JSON objects are unordered.
	    Children of an array appear in array order in the resultant nodelist.</t>
	    <t>Note that the children of an object are its member values, not its member names.</t>
            <t>The wildcard selector selects nothing from a primitive JSON value (that is,
a number, a string, <tt>true</tt>, <tt>false</tt>, or <tt>null</tt>).</t>
          </section>
          <section anchor="examples-2">
            <name>Examples</name>
            <t>JSON:</t>
            <sourcecode type="json"><![CDATA[
{
  "o": {"j": 1, "k": 2},
  "a": [5, 3]
}
]]></sourcecode>
            <t>Queries:</t>
            <t>The examples in <xref target="tbl-wild"/> show the wildcard selector in use by a child segment.</t>
            <table anchor="tbl-wild">
              <name>Wildcard Selector Examples</name>
              <thead>
                <tr>
                  <th align="center">Query</th>
                  <th align="left">Result</th>
                  <th align="center">Result Paths</th>
                  <th align="left">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">
                    <tt>$[*]</tt></td>
                  <td align="left">
                    <tt>{"j": 1, "k": 2}</tt> <br/> <tt>[5, 3]</tt></td>
                  <td align="center">
                    <tt>$['o']</tt> <br/> <tt>$['a']</tt></td>
                  <td align="left">Object values</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o[*]</tt></td>
                  <td align="left">
                    <tt>1</tt> <br/> <tt>2</tt></td>
                  <td align="center">
                    <tt>$['o']['j']</tt> <br/> <tt>$['o']['k']</tt></td>
                  <td align="left">Object values</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o[*]</tt></td>
                  <td align="left">
                    <tt>2</tt> <br/> <tt>1</tt></td>
                  <td align="center">
                    <tt>$['o']['k']</tt> <br/> <tt>$['o']['j']</tt></td>
                  <td align="left">Alternative result</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o[*, *]</tt></td>
                  <td align="left">
                    <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>2</tt> <br/> <tt>1</tt></td>
                  <td align="center">
                    <tt>$['o']['j']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['o']['j']</tt></td>
                  <td align="left">Non-deterministic ordering</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a[*]</tt></td>
                  <td align="left">
                    <tt>5</tt> <br/> <tt>3</tt></td>
                  <td align="center">
                    <tt>$['a'][0]</tt> <br/> <tt>$['a'][1]</tt></td>
                  <td align="left">Array members</td>
                </tr>
              </tbody>
            </table>
            <t>The example above with the query <tt>$.o[*, *]</tt> shows that the wildcard selector may produce nodelists in distinct
orders each time it appears in the child segment when it is applied to an object node with two or more
members (but not when it is applied to object nodes with fewer than two members or to array nodes).</t>
          </section>
        </section>
        <section anchor="index-selector">
          <name>Index Selector</name>
          <section anchor="syntax-index">
            <name>Syntax</name>
            <t>An index selector <tt>&lt;index&gt;</tt> matches at most one array element value.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
index-selector      = int                        ; decimal integer

int                 = "0" /
                      (["-"] DIGIT1 *DIGIT)      ; - optional
DIGIT1              = %x31-39                    ; 1-9 non-zero digit
]]></sourcecode>
            <t>Applying the numerical <tt>index-selector</tt> selects the corresponding
element. JSONPath allows it to be negative (see <xref target="index-semantics"/>).</t>
            <t>To be valid, the index selector value <bcp14>MUST</bcp14> be in the I-JSON
range of exact values (see <xref target="synsem-overview"/>).</t>
            <t>Notes:</t>
            <ul spacing="normal">
              <li>An <tt>index-selector</tt> is an integer (in base 10, as in JSON numbers).</li>
              <li>As in JSON numbers, the syntax does not allow octal-like integers with leading zeros, such as <tt>01</tt> or <tt>-01</tt>.</li>
            </ul>
          </section>
          <section anchor="index-semantics">
            <name>Semantics</name>
            <t>A non-negative <tt>index-selector</tt> applied to an array selects an array element using a zero-based index.
For example, the selector <tt>0</tt> selects the first, and the selector <tt>4</tt> selects the fifth element of a sufficiently long array.
Nothing is selected, and it is not an error, if the index lies outside the range of the array. Nothing is selected from a value that is not an array.</t>
            <t>A negative <tt>index-selector</tt> counts from the array end backwards,
obtaining an equivalent non-negative <tt>index-selector</tt> by adding the
length of the array to the negative index.
For example, the selector <tt>-1</tt> selects the last, and the selector <tt>-2</tt> selects the penultimate element of an array with at least two elements.
As with non-negative indexes, it is not an error if such an element does
not exist; this simply means that no element is selected.</t>
          </section>
          <section anchor="examples-3">
            <name>Examples</name>
<t>JSON:</t>
            <sourcecode type="json"><![CDATA[
["a","b"]
]]></sourcecode>
            <t>Queries:</t>
            <t>The examples in <xref target="tbl-index"/> show the index selector in use by a child segment.</t>
            <table anchor="tbl-index">
              <name>Index Selector Examples</name>
              <thead>
                <tr>
                  <th align="center">Query</th>
                  <th align="left">Result</th>
                  <th align="center">Result Paths</th>
                  <th align="left">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">
                    <tt>$[1]</tt></td>
                  <td align="left">
                    <tt>"b"</tt></td>
                  <td align="center">
                    <tt>$[1]</tt></td>
                  <td align="left">Element of array</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$[-2]</tt></td>
                  <td align="left">
                    <tt>"a"</tt></td>
                  <td align="center">
                    <tt>$[0]</tt></td>
                  <td align="left">Element of array, from the end</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>
        <section anchor="slice">
          <name>Array Slice Selector</name>
          <section anchor="syntax-3">
            <name>Syntax</name>
            <t>The array slice selector has the form <tt>&lt;start&gt;:&lt;end&gt;:&lt;step&gt;</tt>.
It matches elements from arrays starting at index <tt>&lt;start&gt;</tt> and ending at (but
not including) <tt>&lt;end&gt;</tt>, while incrementing by <tt>step</tt> with a default of <tt>1</tt>.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
slice-selector      = [start S] ":" S [end S] [":" [S step ]]

start               = int       ; included in selection
end                 = int       ; not included in selection
step                = int       ; default: 1
]]></sourcecode>
            <t>The slice selector consists of three optional decimal integers separated by colons.
The second colon can be omitted when the third integer is omitted.</t>
            <t>To be valid, the integers provided <bcp14>MUST</bcp14> be in the I-JSON
range of exact values (see <xref target="synsem-overview"/>).</t>
          </section>
          <section anchor="semantics-4">
            <name>Semantics</name>
            <t>The slice selector was inspired by
               the slice operator that was proposed for ECMAScript 4 (ES4), which was never released,
               and that of Python.</t>
            <section anchor="informal-introduction">
              <name>Informal Introduction</name>
              <t>This section is informative.</t>
              <t>Array slicing is inspired by the behavior of the <tt>Array.prototype.slice</tt> method
of the JavaScript language, as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <tt>step</tt> parameter, which is inspired by the Python slice expression.</t>
              <t>The array slice expression <tt>start:end:step</tt> selects elements at indices starting at <tt>start</tt>,
incrementing by <tt>step</tt>, and ending with <tt>end</tt> (which is itself excluded).
So, for example, the expression <tt>1:3</tt> (where <tt>step</tt> defaults to <tt>1</tt>)
selects elements with indices <tt>1</tt> and <tt>2</tt> (in that order), whereas
<tt>1:5:2</tt> selects elements with indices <tt>1</tt> and <tt>3</tt>.</t>
              <t>When <tt>step</tt> is negative, elements are selected in reverse order. Thus,
for example, <tt>5:1:-2</tt> selects elements with indices <tt>5</tt> and <tt>3</tt> (in
that order), and <tt>::-1</tt> selects all the elements of an array in
reverse order.</t>
              <t>When <tt>step</tt> is <tt>0</tt>, no elements are selected.
(This is the one case that differs from the behavior of Python, which
raises an error in this case.)</t>
              <t>The following section specifies the behavior fully, without depending on
JavaScript or Python behavior.</t>
            </section>
            <section anchor="normative-semantics">
              <name>Normative Semantics</name>
              <t>A slice expression selects a subset of the elements of the input array in
the same order
as the array or the reverse order, depending on the sign of the <tt>step</tt> parameter.
It selects no nodes from a node that is not an array.</t>
              <t>A slice is defined by the two slice parameters, <tt>start</tt> and <tt>end</tt>, and
an iteration delta, <tt>step</tt>.
Each of these parameters is
optional. In the rest of this section, <tt>len</tt> denotes the length of the input array.</t>
              <t>The default value for <tt>step</tt> is <tt>1</tt>.
The default values for <tt>start</tt> and <tt>end</tt> depend on the sign of <tt>step</tt>,
as shown in <xref target="tbl-slice-start-end"/>.</t>
              <table anchor="tbl-slice-start-end">
                <name>Default Array Slice start and end Values</name>
                <thead>
                  <tr>
                    <th align="left">Condition</th>
                    <th align="left">start</th>
                    <th align="left">end</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td align="left">step &gt;= 0</td>
                    <td align="left">0</td>
                    <td align="left">len</td>
                  </tr>
                  <tr>
                    <td align="left">step &lt; 0</td>
                    <td align="left">len - 1</td>
                    <td align="left">-len - 1</td>
                  </tr>
                </tbody>
              </table>
              <t>Slice expression parameters <tt>start</tt> and <tt>end</tt> are not directly usable
as slice bounds and must first be normalized.
Normalization for this purpose is defined as:</t>
              <sourcecode type="pseudocode"><![CDATA[
FUNCTION Normalize(i, len):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></sourcecode>
              <t>The result of the array index expression <tt>i</tt> applied to an array
of length <tt>len</tt> is the result of the array
slicing expression <tt>Normalize(i, len):Normalize(i, len)+1:1</tt>.</t>
              <t>Slice expression parameters <tt>start</tt> and <tt>end</tt> are used to derive slice bounds <tt>lower</tt> and <tt>upper</tt>.
The direction of the iteration, defined
by the sign of <tt>step</tt>, determines which of the parameters is the lower bound and which
is the upper bound:</t>
              <sourcecode type="pseudocode"><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start, len)
  n_end = Normalize(end, len)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></sourcecode>
              <t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, <tt>a(i)</tt> is the <tt>i+1</tt>th element of the array <tt>a</tt>
(i.e., <tt>a(0)</tt> is the first element, <tt>a(1)</tt> the second, and so forth).</t>
              <sourcecode type="pseudocode"><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></sourcecode>
              <t>When <tt>step = 0</tt>, no elements are selected, and the result array is empty.</t>
            </section>
          </section>
          <section anchor="examples-4">
            <name>Examples</name>
            <t>JSON:</t>
            <sourcecode type="json"><![CDATA[
["a", "b", "c", "d", "e", "f", "g"]
]]></sourcecode>
            <t>Queries:</t>
            <t>The examples in <xref target="tbl-slice"/> show the array slice selector in use by a child segment.</t>
            <table anchor="tbl-slice">
              <name>Array Slice Selector Examples</name>
              <thead>
                <tr>
                  <th align="center">Query</th>
                  <th align="left">Result</th>
                  <th align="center">Result Paths</th>
                  <th align="left">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">
                    <tt>$[1:3]</tt></td>
                  <td align="left">
                    <tt>"b"</tt> <br/> <tt>"c"</tt></td>
                  <td align="center">
                    <tt>$[1]</tt> <br/> <tt>$[2]</tt></td>
                  <td align="left">Slice with default step</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$[5:]</tt></td>
                  <td align="left">
                    <tt>"f"</tt> <br/> <tt>"g"</tt></td>
                  <td align="center">
                    <tt>$[5]</tt> <br/> <tt>$[6]</tt></td>
                  <td align="left">Slice with no end index</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$[1:5:2]</tt></td>
                  <td align="left">
                    <tt>"b"</tt> <br/> <tt>"d"</tt></td>
                  <td align="center">
                    <tt>$[1]</tt> <br/> <tt>$[3]</tt></td>
                  <td align="left">Slice with step 2</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$[5:1:-2]</tt></td>
                  <td align="left">
                    <tt>"f"</tt> <br/> <tt>"d"</tt></td>
                  <td align="center">
                    <tt>$[5]</tt> <br/> <tt>$[3]</tt></td>
                  <td align="left">Slice with negative step</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$[::-1]</tt></td>
                  <td align="left">
                    <tt>"g"</tt> <br/> <tt>"f"</tt> <br/> <tt>"e"</tt> <br/> <tt>"d"</tt> <br/> <tt>"c"</tt> <br/> <tt>"b"</tt> <br/> <tt>"a"</tt></td>
                  <td align="center">
                    <tt>$[6]</tt> <br/> <tt>$[5]</tt> <br/> <tt>$[4]</tt> <br/> <tt>$[3]</tt> <br/> <tt>$[2]</tt> <br/> <tt>$[1]</tt> <br/> <tt>$[0]</tt></td>
                  <td align="left">Slice in reverse order</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>
        <section anchor="filter-selector">
          <name>Filter Selector</name>
          <t>Filter selectors are used to iterate over the elements or members of
structured values, i.e., JSON arrays and objects.
The structured values are identified in the nodelist offered by the
child or descendant segment using the filter selector.</t>
          <t>For each iteration (element/member), a logical expression (the <em>filter expression</em>)
is evaluated, which decides whether the node of
the element/member is selected.
(While a logical expression evaluates to what mathematically is a
Boolean value, this specification uses the term <em>logical</em> to maintain a distinction from
the Boolean values that JSON can represent.)</t>
          <t>During the iteration process, the filter expression receives the node
of each array element or object member value of the structured value being
filtered; this element or member value is then known as the <em>current node</em>.</t>
          <t>The current node can be used as the start of one or more JSONPath
queries in subexpressions of the filter expression, notated
via the current-node-identifier <tt>@</tt>.
Each JSONPath query can be used either for testing existence of a
result of the query, for obtaining a specific JSON value resulting
from that query that can then be used in a comparison, or as a
<em>function argument</em>.</t>
          <t>Filter selectors may use function extensions, which are covered in <xref target="fnex"/>.
Within the logical expression for a filter selector, function
expressions can be used to operate on nodelists and values.
The set of available functions is extensible, with a number of
functions predefined (see <xref target="fnex"/>) and the ability to register further
functions provided by the "Function Extensions" subregistry (<xref target="iana-fnex"/>).
When a function is defined, it is given a unique name, and its return value and each of its parameters are given a
<em>declared type</em>.
The type system is limited in scope; its purpose is to express
restrictions that, without functions, are implicit in the grammar of
filter expressions.
The type system also guides conversions (<xref target="type-conv"/>) that mimic the
way different kinds of expressions are handled in the grammar when
function expressions are not in use.</t>
          <section anchor="filter-selector-syntax">
            <name>Syntax</name>
            <t>The filter selector has the form <tt>?&lt;logical-expr&gt;</tt>.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
filter-selector     = "?" S logical-expr
]]></sourcecode>
            <t>As the filter expression is composed of constituents free of side effects,
the order of evaluation does not need to be (and is not) defined.
Similarly, for conjunction (<tt>&amp;&amp;</tt>) and disjunction (<tt>||</tt>) (defined later),
both a short-circuiting and a fully evaluating
implementation will lead to the same result; both implementation
strategies are therefore valid.</t>
            <t>The current node is accessible via the current node identifier <tt>@</tt>.
This identifier addresses the current node of the filter-selector that
is directly enclosing the identifier. Note: Within nested
filter-selectors, there is no syntax to address the current node of
any other than the directly enclosing filter-selector (i.e., of
filter-selectors enclosing the filter-selector that is directly
enclosing the identifier).</t>
            <t>Logical expressions offer the usual Boolean operators (<tt>||</tt> for OR,
<tt>&amp;&amp;</tt> for AND, and <tt>!</tt> for NOT).
They have the normal semantics of Boolean algebra and obey its laws
(for example, see <xref target="BOOLEAN-LAWS"/>).
Parentheses <bcp14>MAY</bcp14> be used within <tt>logical-expr</tt> for grouping.</t>
            <t>It is not required that <tt>logical-expr</tt> consist of
a parenthesized expression (which was required in <xref target="JSONPath-orig"/>),
although it can be, and the semantics are the same
as without the parentheses.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
logical-expr        = logical-or-expr
logical-or-expr     = logical-and-expr *(S "||" S logical-and-expr)
                        ; disjunction
                        ; binds less tightly than conjunction
logical-and-expr    = basic-expr *(S "&&" S basic-expr)
                        ; conjunction
                        ; binds more tightly than disjunction

basic-expr          = paren-expr /
                      comparison-expr /
                      test-expr

paren-expr          = [logical-not-op S] "(" S logical-expr S ")"
                                        ; parenthesized expression
logical-not-op      = "!"               ; logical NOT operator
]]></sourcecode>
            <t>A test expression
either tests the existence of a node
designated by an embedded query (see <xref target="extest"/>) or tests the
result of a function expression (see <xref target="fnex"/>).
In the latter case, if the function's declared result type is
<tt>LogicalType</tt> (see <xref target="typesys"/>), it tests whether the result
is <tt>LogicalTrue</tt>; if the function's declared result type is
<tt>NodesType</tt>, it tests whether the result is non-empty.
If the function's declared result type is <tt>ValueType</tt>, its use in a
test expression is not well-typed (see <xref target="well-typedness"/>).</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
test-expr           = [logical-not-op S]
                      (filter-query / ; existence/non-existence
                       function-expr) ; LogicalType or NodesType
filter-query        = rel-query / jsonpath-query
rel-query           = current-node-identifier segments
current-node-identifier = "@"
]]></sourcecode>
            <t>Comparison expressions are available for comparisons between primitive
values (that is, numbers, strings, <tt>true</tt>, <tt>false</tt>, and <tt>null</tt>).
These can be obtained via literal values; singular queries, each of
which selects at most one node, the value of which is then used; or
function expressions (see <xref target="fnex"/>) of type <tt>ValueType</tt>.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
comparison-expr     = comparable S comparison-op S comparable
literal             = number / string-literal /
                      true / false / null
comparable          = literal /
                      singular-query / ; singular query value
                      function-expr    ; ValueType
comparison-op       = "==" / "!=" /
                      "<=" / ">=" /
                      "<"  / ">"

singular-query      = rel-singular-query / abs-singular-query
rel-singular-query  = current-node-identifier singular-query-segments
abs-singular-query  = root-identifier singular-query-segments
singular-query-segments = *(S (name-segment / index-segment))
name-segment        = ("[" name-selector "]") /
                      ("." member-name-shorthand)
index-segment       = "[" index-selector "]"
]]></sourcecode>
            <t>Literals can be notated in the way that is usual for JSON (with the
extension that strings can use single-quote delimiters).</t>
            <t>Note: Alphabetic characters in quoted strings are case-insensitive in ABNF, so within a
floating point number, the ABNF expression "e" can be either the character
'e' or 'E'.</t>
            <t><tt>true</tt>, <tt>false</tt>, and <tt>null</tt> are lowercase only (case-sensitive).</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
number              = (int / "-0") [ frac ] [ exp ] ; decimal number
frac                = "." 1*DIGIT                  ; decimal fraction
exp                 = "e" [ "-" / "+" ] 1*DIGIT    ; decimal exponent
true                = %x74.72.75.65                ; true
false               = %x66.61.6c.73.65             ; false
null                = %x6e.75.6c.6c                ; null
]]></sourcecode>
            <t><xref target="tbl-prec"/> lists filter expression operators in order of precedence from highest (binds most tightly) to lowest (binds least tightly).</t>
<table anchor="tbl-prec">
              <name>Filter Expression Operator Precedence</name>
              <thead>
                <tr>
                  <th align="center">Precedence</th>
                  <th align="center">Operator type</th>
                  <th align="center">Syntax</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">5</td>
                  <td align="center">Grouping <br/> Function Expressions</td>
                  <td align="center">
                    <tt>(...)</tt> <br/> <em>name</em><tt>(...)</tt></td>
                </tr>
                <tr>
                  <td align="center">4</td>
                  <td align="center">Logical NOT</td>
                  <td align="center">
                    <tt>!</tt></td>
                </tr>
                <tr>
                  <td align="center">3</td>
                  <td align="center">Relations</td>
                  <td align="center">
                    <tt>==</tt> <tt>!=</tt><br/><tt>&lt;</tt> <tt>&lt;=</tt> <tt>&gt;</tt> <tt>&gt;=</tt></td>
                </tr>
                <tr>
                  <td align="center">2</td>
                  <td align="center">Logical AND</td>
                  <td align="center">
                    <tt>&amp;&amp;</tt></td>
                </tr>
                <tr>
                  <td align="center">1</td>
                  <td align="center">Logical OR</td>
                  <td align="center">
                    <tt>||</tt></td>
                </tr>
              </tbody>
            </table>
          </section>
          <section anchor="semantics-5">
            <name>Semantics</name>
            <t>The filter selector works with arrays and objects exclusively. Its result is a list of (<em>zero</em>, <em>one</em>, <em>multiple</em>, or <em>all</em>) their array elements or member values, respectively.
Applied to a primitive value, it selects nothing (and therefore does
not contribute to the result of the filter selector).</t>
            <t>In the resultant nodelist, children of an array are ordered by their position in the array.
The order in which the children of an object (as opposed to an array)
appear in the resultant nodelist is not stipulated,
since JSON objects are unordered.</t>
            <section anchor="extest">
              <name>Existence Tests</name>
              <t>A query by itself in a logical context is an existence test that yields true if the query selects at least one node and yields false if the query does not select any nodes.</t>
              <t>Existence tests differ from comparisons in that:</t>
              <ul spacing="normal">
                <li>They work with arbitrary relative or absolute queries (not just singular queries).</li>
                <li>They work with queries that select structured values.</li>
              </ul>
              <t>To examine the value of a node selected by a query, an explicit comparison is necessary.
For example, to test whether the node selected by the query <tt>@.foo</tt> has the value <tt>null</tt>, use <tt>@.foo == null</tt> (see <xref target="null-semantics"/>)
rather than the negated existence test <tt>!@.foo</tt> (which yields false if <tt>@.foo</tt> selects a node, regardless of the node's value).
Similarly, <tt>@.foo == false</tt> yields true only if <tt>@.foo</tt> selects a node and
the value of that node is <tt>false</tt>.</t>
            </section>
            <section anchor="comparisons">
              <name>Comparisons</name>
              <t>The comparison operators <tt>==</tt> and <tt>&lt;</tt> are defined first, and then these are used to define <tt>!=</tt>, <tt>&lt;=</tt>, <tt>&gt;</tt>, and <tt>&gt;=</tt>.</t>
              <t>When either side of a comparison results in an empty nodelist or the
special result <tt>Nothing</tt> (see <xref target="typesys"/>):</t>
              <ul spacing="normal">
                <li>A comparison using the operator <tt>==</tt> yields true if and only the
other side also results in an empty nodelist or the special result <tt>Nothing</tt>.</li>
                <li>A comparison using the operator <tt>&lt;</tt> yields false.</li>
              </ul>
              <t>When any query or function expression on either side of a comparison results in a nodelist consisting of a single node, that side is
replaced by the value of its node and then:</t>
              <ul spacing="normal">
                <li>
                  <t>A comparison using the operator <tt>==</tt> yields true if and only if the comparison
is between:
                  </t>
                  <ul spacing="normal">
                    <li>numbers expected to interoperate, as per <xref section="2.2" sectionFormat="of" target="RFC7493">I-JSON</xref>, that compare equal using normal mathematical equality,</li>
                    <li>numbers, at least one of which is not expected to interoperate as per I-JSON, where the numbers compare equal using an implementation-specific equality,</li>
                    <li>equal primitive values that are not numbers,</li>
                    <li>equal arrays, that is, arrays of the same length where each element of the first array is equal to the corresponding
element of the second array, or</li>
                    <li>
                      <t>equal objects with no duplicate names, that is, where:
                      </t>
                      <ul spacing="normal">
                        <li>both objects have the same collection of names (with no duplicates) and</li>
                        <li>for each of those names, the values associated with the name by the objects are equal.</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>
                  <t>A comparison using the operator <tt>&lt;</tt> yields true if and only if
the comparison is between values that are both numbers or both strings and that satisfy the comparison:  </t>
                  <ul spacing="normal">
                    <li>numbers expected to interoperate, as per <xref section="2.2" sectionFormat="of" target="RFC7493">I-JSON</xref>, <bcp14>MUST</bcp14> compare using the normal mathematical ordering;
numbers not expected to interoperate, as per I-JSON, <bcp14>MAY</bcp14> compare using an implementation-specific ordering,</li>
                    <li>the empty string compares less than any non-empty string, and</li>
                    <li>a non-empty string compares less than another non-empty string if and only if the first string starts with a
lower Unicode scalar value than the second string or if both strings start with the same Unicode scalar value and
the remainder of the first string compares less than the remainder of the second string.</li>
                  </ul>
                </li>
              </ul>
              <t><tt>!=</tt>, <tt>&lt;=</tt>, <tt>&gt;</tt>, and <tt>&gt;=</tt> are defined in terms of the other comparison operators. For any <tt>a</tt> and <tt>b</tt>:</t>
              <ul spacing="normal">
                <li>The comparison <tt>a != b</tt> yields true if and only if <tt>a == b</tt> yields false.</li>
                <li>The comparison <tt>a &lt;= b</tt> yields true if and only if <tt>a &lt; b</tt> yields true or <tt>a == b</tt> yields true.</li>
                <li>The comparison <tt>a &gt; b</tt> yields true if and only if <tt>b &lt; a</tt> yields true.</li>
                <li>The comparison <tt>a &gt;= b</tt> yields true if and only if <tt>b &lt; a</tt> yields true or <tt>a == b</tt> yields true.</li>
              </ul>
            </section>
          </section>
          <section anchor="examples-5">
            <name>Examples</name>
            <t>The first set of examples shows some comparison expressions and their
result with a given JSON value as input.</t>
            <t>JSON:</t>
            <sourcecode type="json"><![CDATA[
{
  "obj": {"x": "y"},
  "arr": [2, 3]
}
]]></sourcecode>
            <t>Comparisons:</t>
            <table anchor="tbl-comparison">
              <name>Comparison Examples</name>
              <thead>
                <tr>
                  <th align="center">Comparison</th>
                  <th align="center">Result</th>
                  <th align="center">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">
                    <tt>$.absent1 == $.absent2</tt></td>
                  <td align="center">true</td>
                  <td align="center">Empty nodelists</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.absent1 &lt;= $.absent2</tt></td>
                  <td align="center">true</td>
                  <td align="center">
                    <tt>==</tt> implies <tt>&lt;=</tt></td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.absent == 'g'</tt></td>
                  <td align="center">false</td>
                  <td align="center">Empty nodelist</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.absent1 != $.absent2</tt></td>
                  <td align="center">false</td>
                  <td align="center">Empty nodelists</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.absent != 'g'</tt></td>
                  <td align="center">true</td>
                  <td align="center">Empty nodelist</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>1 &lt;= 2</tt></td>
                  <td align="center">true</td>
                  <td align="center">Numeric comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>1 &gt; 2</tt></td>
                  <td align="center">false</td>
                  <td align="center">Strict, numeric comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>13 == '13'</tt></td>
                  <td align="center">false</td>
                  <td align="center">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>'a' &lt;= 'b'</tt></td>
                  <td align="center">true</td>
                  <td align="center">String comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>'a' &gt; 'b'</tt></td>
                  <td align="center">false</td>
                  <td align="center">Strict, string comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.obj == $.arr</tt></td>
                  <td align="center">false</td>
                  <td align="center">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.obj != $.arr</tt></td>
                  <td align="center">true</td>
                  <td align="center">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.obj == $.obj</tt></td>
                  <td align="center">true</td>
                  <td align="center">Object comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.obj != $.obj</tt></td>
                  <td align="center">false</td>
                  <td align="center">Object comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.arr == $.arr</tt></td>
                  <td align="center">true</td>
                  <td align="center">Array comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.arr != $.arr</tt></td>
                  <td align="center">false</td>
                  <td align="center">Array comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.obj == 17</tt></td>
                  <td align="center">false</td>
                  <td align="center">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.obj != 17</tt></td>
                  <td align="center">true</td>
                  <td align="center">Type mismatch</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.obj &lt;= $.arr</tt></td>
                  <td align="center">false</td>
                  <td align="center">Objects and arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.obj &lt; $.arr</tt></td>
                  <td align="center">false</td>
                  <td align="center">Objects and arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.obj &lt;= $.obj</tt></td>
                  <td align="center">true</td>
                  <td align="center">
                    <tt>==</tt> implies <tt>&lt;=</tt></td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.arr &lt;= $.arr</tt></td>
                  <td align="center">true</td>
                  <td align="center">
                    <tt>==</tt> implies <tt>&lt;=</tt></td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>1 &lt;= $.arr</tt></td>
                  <td align="center">false</td>
                  <td align="center">Arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>1 &gt;= $.arr</tt></td>
                  <td align="center">false</td>
                  <td align="center">Arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>1 &gt; $.arr</tt></td>
                  <td align="center">false</td>
                  <td align="center">Arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>1 &lt; $.arr</tt></td>
                  <td align="center">false</td>
                  <td align="center">Arrays do not offer <tt>&lt;</tt> comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>true &lt;= true</tt></td>
                  <td align="center">true</td>
                  <td align="center">
                    <tt>==</tt> implies <tt>&lt;=</tt></td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>true &gt; true</tt></td>
                  <td align="center">false</td>
                  <td align="center">Booleans do not offer <tt>&lt;</tt> comparison</td>
                </tr>
              </tbody>
            </table>
            <t>The second set of examples shows some complete JSONPath queries that make use
of filter selectors and the results of evaluating these queries on a
given JSON value as input.
(Note: Two of the queries employ function extensions; please see
Sections <xref format="counter" target="match"/> and <xref format="counter" target="search"/> for details about these.)</t>
            <t>JSON:</t>
            <sourcecode type="json"><![CDATA[
{
  "a": [3, 5, 1, 2, 4, 6,
        {"b": "j"},
        {"b": "k"},
        {"b": {}},
        {"b": "kilo"}
       ],
  "o": {"p": 1, "q": 2, "r": 3, "s": 5, "t": {"u": 6}},
  "e": "f"
}
]]></sourcecode>
            <t>Queries:</t>
            <t>The examples in <xref target="tbl-filter"/> show the filter selector in use by a child segment.</t>
            <table anchor="tbl-filter">
              <name>Filter Selector Examples</name>
              <thead>
                <tr>
                  <th align="center">Query</th>
                  <th align="left">Result</th>
                  <th align="center">Result Paths</th>
                  <th align="left">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">
                    <tt>$.a[?@.b == 'kilo']</tt></td>
                  <td align="left">
                    <tt>{"b": "kilo"}</tt></td>
                  <td align="center">
                    <tt>$['a'][9]</tt></td>
                  <td align="left">Member value comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a[?(@.b == 'kilo')]</tt></td>
                  <td align="left">
                    <tt>{"b": "kilo"}</tt></td>
                  <td align="center">
                    <tt>$['a'][9]</tt></td>
                  <td align="left">Equivalent query with enclosing parentheses</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a[?@&gt;3.5]</tt></td>
                  <td align="left">
                    <tt>5</tt> <br/> <tt>4</tt> <br/> <tt>6</tt></td>
                  <td align="center">
                    <tt>$['a'][1]</tt> <br/> <tt>$['a'][4]</tt> <br/> <tt>$['a'][5]</tt></td>
                  <td align="left">Array value comparison</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a[?@.b]</tt></td>
                  <td align="left">
                    <tt>{"b": "j"}</tt> <br/> <tt>{"b": "k"}</tt> <br/> <tt>{"b": {}}</tt> <br/> <tt>{"b": "kilo"}</tt></td>
                  <td align="center">
                    <tt>$['a'][6]</tt> <br/> <tt>$['a'][7]</tt> <br/> <tt>$['a'][8]</tt> <br/> <tt>$['a'][9]</tt></td>
                  <td align="left">Array value existence</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$[?@.*]</tt></td>
                  <td align="left">
                    <tt>[3, 5, 1, 2, 4, 6, {"b": "j"}, {"b": "k"}, {"b": {}}, {"b": "kilo"}]</tt> <br/> <tt>{"p": 1, "q": 2, "r": 3, "s": 5, "t": {"u": 6}}</tt></td>
                  <td align="center">
                    <tt>$['a']</tt> <br/> <tt>$['o']</tt></td>
                  <td align="left">Existence of non-singular queries</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$[?@[?@.b]]</tt></td>
                  <td align="left">
                    <tt>[3, 5, 1, 2, 4, 6, {"b": "j"}, {"b": "k"}, {"b": {}}, {"b": "kilo"}]</tt></td>
                  <td align="center">
                    <tt>$['a']</tt></td>
                  <td align="left">Nested filters</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o[?@&lt;3, ?@&lt;3]</tt></td>
                  <td align="left">
                    <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>2</tt> <br/> <tt>1</tt></td>
                  <td align="center">
                    <tt>$['o']['p']</tt> <br/> <tt>$['o']['q']</tt> <br/> <tt>$['o']['q']</tt> <br/> <tt>$['o']['p']</tt></td>
                  <td align="left">Non-deterministic ordering</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a[?@&lt;2 || @.b == "k"]</tt></td>
                  <td align="left">
                    <tt>1</tt> <br/> <tt>{"b": "k"}</tt></td>
                  <td align="center">
                    <tt>$['a'][2]</tt> <br/> <tt>$['a'][7]</tt></td>
                  <td align="left">Array value logical OR</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a[?match(@.b, "[jk]")]</tt></td>
                  <td align="left">
                    <tt>{"b": "j"}</tt> <br/> <tt>{"b": "k"}</tt></td>
                  <td align="center">
                    <tt>$['a'][6]</tt> <br/> <tt>$['a'][7]</tt></td>
                  <td align="left">Array value regular expression match</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a[?search(@.b, "[jk]")]</tt></td>
                  <td align="left">
                    <tt>{"b": "j"}</tt> <br/> <tt>{"b": "k"}</tt> <br/> <tt>{"b": "kilo"}</tt></td>
                  <td align="center">
                    <tt>$['a'][6]</tt> <br/> <tt>$['a'][7]</tt> <br/> <tt>$['a'][9]</tt></td>
                  <td align="left">Array value regular expression search</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o[?@&gt;1 &amp;&amp; @&lt;4]</tt></td>
                  <td align="left">
                    <tt>2</tt> <br/> <tt>3</tt></td>
                  <td align="center">
                    <tt>$['o']['q']</tt> <br/> <tt>$['o']['r']</tt></td>
                  <td align="left">Object value logical AND</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o[?@&gt;1 &amp;&amp; @&lt;4]</tt></td>
                  <td align="left">
                    <tt>3</tt> <br/> <tt>2</tt></td>
                  <td align="center">
                    <tt>$['o']['r']</tt> <br/> <tt>$['o']['q']</tt></td>
                  <td align="left">Alternative result</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o[?@.u || @.x]</tt></td>
                  <td align="left">
                    <tt>{"u": 6}</tt></td>
                  <td align="center">
                    <tt>$['o']['t']</tt></td>
                  <td align="left">Object value logical OR</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a[?@.b == $.x]</tt></td>
                  <td align="left">
                    <tt>3</tt> <br/> <tt>5</tt> <br/> <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>4</tt> <br/> <tt>6</tt></td>
                  <td align="center">
                    <tt>$['a'][0]</tt> <br/><tt>$['a'][1]</tt> <br/> <tt>$['a'][2]</tt> <br/> <tt>$['a'][3]</tt> <br/> <tt>$['a'][4]</tt> <br/> <tt>$['a'][5]</tt></td>
                  <td align="left">Comparison of queries with no values</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a[?@ == @]</tt></td>
                  <td align="left">
                    <tt>3</tt> <br/> <tt>5</tt> <br/> <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>4</tt> <br/> <tt>6</tt> <br/> <tt>{"b": "j"}</tt> <br/> <tt>{"b": "k"}</tt> <br/> <tt>{"b": {}}</tt> <br/> <tt>{"b": "kilo"}</tt></td>
                  <td align="center">
                    <tt>$['a'][0]</tt> <br/> <tt>$['a'][1]</tt> <br/><tt>$['a'][2]</tt> <br/><tt>$['a'][3]</tt> <br/><tt>$['a'][4]</tt> <br/><tt>$['a'][5]</tt> <br/><tt>$['a'][6]</tt> <br/><tt>$['a'][7]</tt> <br/><tt>$['a'][8]</tt> <br/><tt>$['a'][9]</tt></td>
                  <td align="left">Comparisons of primitive and of structured values</td>
                </tr>
              </tbody>
            </table>
            <t>The example above with the query <tt>$.o[?@&lt;3, ?@&lt;3]</tt> shows that a filter selector may produce nodelists in distinct
orders each time it appears in the child segment.</t>
          </section>
        </section>
      </section>
      <section anchor="fnex">
        <name>Function Extensions</name>
        <t>Beyond the filter expression functionality defined in the preceding
subsections, JSONPath defines an extension point that can be used to
add filter expression functionality: "Function Extensions".</t>
        <t>This section defines the extension point and some function
extensions that use this extension point.
While these mechanisms are designed to use the extension point,
they are an integral part of the JSONPath specification and are
expected to be implemented like any other integral part of this
specification.</t>
        <t>A function extension defines a registered name (see <xref target="iana-fnex"/>) that
can be applied to a sequence of zero or more arguments, producing a
result. Each registered function name is unique.</t>
        <t>A function extension <bcp14>MUST</bcp14> be defined such that its evaluation is
free of side effects, i.e., all possible orders of evaluation and choices
of short-circuiting or full evaluation of an expression containing it
<bcp14>MUST</bcp14> lead to the same result.
(Note: Memoization or logging are not side effects in this sense
as they are visible at the implementation level only -- they do not
influence the result of the evaluation.)</t>
        <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
function-name       = function-name-first *function-name-char
function-name-first = LCALPHA
function-name-char  = function-name-first / "_" / DIGIT
LCALPHA             = %x61-7A  ; "a".."z"

function-expr       = function-name "(" S [function-argument
                         *(S "," S function-argument)] S ")"
function-argument   = literal /
                      filter-query / ; (includes singular-query)
                      logical-expr /
                      function-expr
]]></sourcecode>
        <t>Any function expressions in a query must be well-formed (by conforming to the above ABNF)
and well-typed;
otherwise, the JSONPath implementation <bcp14>MUST</bcp14> raise an error
(see <xref target="synsem-overview"/>).
To define which function expressions are well-typed,
a type system is first introduced.</t>
        <section anchor="typesys">
          <name>Type System for Function Expressions</name>
          <t>Each parameter and the result of a function extension must have a declared type.</t>
          <t>Declared types enable checking a JSONPath query for well-typedness
independent of any query argument the JSONPath query is applied to.</t>
          <t><xref target="tbl-types"/> defines the available types in terms of the instances they contain.</t>
          <table anchor="tbl-types">
            <name>Function Extension Type System</name>
            <thead>
              <tr>
                <th align="left">Type</th>
                <th align="left">Instances</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">
                  <tt>ValueType</tt></td>
                <td align="left">JSON values or <tt>Nothing</tt></td>
              </tr>
              <tr>
                <td align="left">
                  <tt>LogicalType</tt></td>
                <td align="left">
                  <tt>LogicalTrue</tt> or <tt>LogicalFalse</tt></td>
              </tr>
              <tr>
                <td align="left">
                  <tt>NodesType</tt></td>
                <td align="left">Nodelists</td>
              </tr>
            </tbody>
          </table>
          <t>Notes:</t>
          <ul spacing="normal">
            <li>The only instances that can be directly represented in JSONPath syntax are certain JSON values
in <tt>ValueType</tt> expressed as literals (which, in JSONPath, are limited to primitive values).</li>
            <li>The special result <tt>Nothing</tt> represents the absence of a JSON value and is distinct from any JSON value, including <tt>null</tt>.</li>
            <li>
              <tt>LogicalTrue</tt> and <tt>LogicalFalse</tt> are unrelated to the JSON values expressed by the
literals <tt>true</tt> and <tt>false</tt>.</li>
          </ul>
        </section>
        <section anchor="type-conv">
          <name>Type Conversion</name>
          <t>Just as queries can be used in logical expressions by testing for the
existence of at least one node (<xref target="extest"/>), a function expression of
declared type <tt>NodesType</tt> can be used as a function argument for a
parameter of declared type <tt>LogicalType</tt>, with the equivalent conversion rule:</t>
          <ul spacing="normal">
            <li>If the nodelist contains one or more nodes, the conversion result is <tt>LogicalTrue</tt>.</li>
            <li>If the nodelist is empty, the conversion result is <tt>LogicalFalse</tt>.</li>
          </ul>
          <t>Notes:</t>
          <ul spacing="normal">
            <li>Extraction of a value from a nodelist can be performed in several
ways, so an implicit conversion from <tt>NodesType</tt> to <tt>ValueType</tt>
may be surprising and has therefore not been defined.</li>
            <li>A function expression with a declared type of <tt>NodesType</tt> can
indirectly be used as an argument for a parameter of declared type
<tt>ValueType</tt> by wrapping the expression in a call to a function extension,
such as <tt>value()</tt> (see <xref target="value"/>),
that takes a parameter of type <tt>NodesType</tt> and returns a
result of type <tt>ValueType</tt>.</li>
          </ul>
          <t>The well-typedness of function expressions can now be defined in terms of this type system.</t>
        </section>
        <section anchor="well-typedness">
          <name>Well-Typedness of Function Expressions</name>
          <t>For a function expression to be well-typed:</t>
          <ol spacing="normal" type="1">
	    <li><t>Its declared type must be well-typed in the context in which it occurs.</t>
<t>As per the grammar, a function expression can occur in three different                       
immediate contexts, which lead to the following conditions for well-typedness:</t>
          <dl newline="true">
            <dt>As a <tt>test-expr</tt> in a logical expression:</dt>
            <dd>
              <t>The function's declared result type is <tt>LogicalType</tt> or                              
(giving rise to conversion as per <xref target="type-conv"/>) <tt>NodesType</tt>.</t>
            </dd>
            <dt>As a <tt>comparable</tt> in a comparison:</dt>
            <dd>
              <t>The function's declared result type is <tt>ValueType</tt>.</t>
            </dd>
            <dt>As a <tt>function-argument</tt> in another function expression:</dt>
            <dd>
              <t>The function's declared result type fulfills the following rules for                         
the corresponding parameter of the enclosing function.</t>
            </dd>
          </dl>
	    </li>
            <li><t>Its arguments must be well-typed for the declared type of the corresponding parameters.</t>
	    <t>The arguments of the function expression are well-typed when
each argument of the function can be used for the declared type of the
corresponding parameter, according to one of the following
conditions:</t>
          <ul spacing="normal">
            <li>When the argument is a function expression with the same declared result type as the
declared type of the parameter.</li>
            <li>
              <t>When the declared type of the parameter is <tt>LogicalType</tt> and the argument is one of the following:
              </t>
              <ul spacing="normal">
                <li>A function expression with declared result type <tt>NodesType</tt>.
In this case, the argument is converted to LogicalType as per <xref target="type-conv"/>.</li>
                <li>A <tt>logical-expr</tt> that is not a function expression.</li>
              </ul>
            </li>
            <li>When the declared type of the parameter is <tt>NodesType</tt> and the argument is a query
(which includes singular query).</li>
            <li>
              <t>When the declared type of the parameter is <tt>ValueType</tt> and the argument is one of the following:
              </t>
              <ul spacing="normal">
                <li>A value expressed as a literal.</li>
                <li>
                  <t>A singular query. In this case:
                  </t>
                  <ul spacing="normal">
                    <li>If the query results in a nodelist consisting of a single node, the
argument is the value of the node.</li>
                    <li>If the query results in an empty nodelist, the argument is
the special result <tt>Nothing</tt>.</li>
                  </ul>
                </li>
              </ul>
	    </li>
	  </ul>
	    </li>
        </ol>
        </section>
        <section anchor="length">
          <name><tt>length()</tt> Function Extension</name>
          <dl>
            <dt>Parameters:</dt>
            <dd>
              <ol spacing="normal" type="1"><li>
                  <tt>ValueType</tt></li>
              </ol>
            </dd>
            <dt>Result:</dt>
            <dd>
              <t><tt>ValueType</tt> (unsigned integer or <tt>Nothing</tt>)</t>
            </dd>
          </dl>
          <t>The <tt>length()</tt> function extension provides a way to compute the length
of a value and make that available for further processing in the
filter expression:</t>
          <sourcecode type="application/jsonpath"><![CDATA[
$[?length(@.authors) >= 5]
]]></sourcecode>
          <t>Its only argument is an instance of <tt>ValueType</tt> (possibly taken from a
singular query, as in the example above).  The result is also an
instance of <tt>ValueType</tt>: an unsigned integer or the special result <tt>Nothing</tt>.</t>
          <ul spacing="normal">
            <li>If the argument value is a string, the result is the number of
Unicode scalar values in the string.</li>
            <li>If the argument value is an array, the result is the number of
elements in the array.</li>
            <li>If the argument value is an object, the result is the number of
members in the object.</li>
            <li>For any other argument value, the result is the special result <tt>Nothing</tt>.</li>
          </ul>
        </section>
        <section anchor="count">
          <name><tt>count()</tt> Function Extension</name>
          <dl>
            <dt>Parameters:</dt>
            <dd>
              <ol spacing="normal" type="1"><li>
                  <tt>NodesType</tt></li>
              </ol>
            </dd>
            <dt>Result:</dt>
            <dd>
              <t><tt>ValueType</tt> (unsigned integer)</t>
            </dd>
          </dl>
          <t>The <tt>count()</tt> function extension provides a way to obtain the number of
nodes in a nodelist and make that available for further processing in
the filter expression:</t>
          <sourcecode type="application/jsonpath"><![CDATA[
$[?count(@.*.author) >= 5]
]]></sourcecode>
          <t>Its only argument is a nodelist.
The result is a value (an unsigned integer) that gives the number of
nodes in the nodelist.</t>
<t>Notes:</t>
          <ul spacing="normal">
            <li>There is no deduplication of the nodelist.</li>
            <li>The number of nodes in the nodelist is counted independent of their
values or any children they may have, e.g., the count of a non-empty
singular nodelist such as <tt>count(@)</tt> is always 1.</li>
          </ul>
        </section>
        <section anchor="match">
          <name><tt>match()</tt> Function Extension</name>
          <dl>
            <dt>Parameters:</dt>
            <dd>
              <ol spacing="normal" type="1"><li>
                  <tt>ValueType</tt> (string)</li>
                <li>
                  <tt>ValueType</tt> (string conforming to <xref target="RFC9485"/>)</li>
              </ol>
            </dd>
            <dt>Result:</dt>
            <dd>
              <t><tt>LogicalType</tt></t>
            </dd>
          </dl>
          <t>The <tt>match()</tt> function extension provides a way to check whether (the
entirety of; see <xref target="search"/>) a given
string matches a given regular expression, which is in the form described in <xref target="RFC9485"/>.</t>
          <sourcecode type="application/jsonpath"><![CDATA[
$[?match(@.date, "1974-05-..")]
]]></sourcecode>
          <t>Its arguments are instances of <tt>ValueType</tt> (possibly taken from a
singular query, as for the first argument in the example above).
If the first argument is not a string or the second argument is not a
string conforming to <xref target="RFC9485"/>, the result is <tt>LogicalFalse</tt>.
Otherwise, the string that is the first argument is matched against
the I-Regexp contained in the string that is the second argument;
the result is <tt>LogicalTrue</tt> if the string matches the I-Regexp and is
<tt>LogicalFalse</tt> otherwise.</t>
        </section>
        <section anchor="search">
          <name><tt>search()</tt> Function Extension</name>
          <dl>
            <dt>Parameters:</dt>
            <dd>
              <ol spacing="normal" type="1"><li>
                  <tt>ValueType</tt> (string)</li>
                <li>
                  <tt>ValueType</tt> (string conforming to <xref target="RFC9485"/>)</li>
              </ol>
            </dd>
            <dt>Result:</dt>
            <dd>
              <t><tt>LogicalType</tt></t>
            </dd>
          </dl>
          <t>The <tt>search()</tt> function extension provides a way to check whether a
given string contains a substring that matches a given regular
expression, which is in the form described in <xref target="RFC9485"/>.</t>
          <sourcecode type="application/jsonpath"><![CDATA[
$[?search(@.author, "[BR]ob")]
]]></sourcecode>
          <t>Its arguments are instances of <tt>ValueType</tt> (possibly taken from a
singular query, as for the first argument in the example above).
If the first argument is not a string or the second argument is not a
string conforming to <xref target="RFC9485"/>, the result is <tt>LogicalFalse</tt>.
Otherwise, the string that is the first argument is searched for a
substring that matches the I-Regexp contained in the string
that is the second argument; the result is <tt>LogicalTrue</tt> if at
least one such substring exists and is <tt>LogicalFalse</tt> otherwise.</t>
        </section>
        <section anchor="value">
          <name><tt>value()</tt> Function Extension</name>
          <dl>
            <dt>Parameters:</dt>
            <dd>
              <ol spacing="normal" type="1"><li>
                  <tt>NodesType</tt></li>
              </ol>
            </dd>
            <dt>Result:</dt>
            <dd>
              <t><tt>ValueType</tt></t>
            </dd>
          </dl>
          <t>The <tt>value()</tt> function extension provides a way to convert an instance of <tt>NodesType</tt> to a value and
make that available for further processing in the filter expression:</t>
          <sourcecode type="application/jsonpath"><![CDATA[
$[?value(@..color) == "red"]
]]></sourcecode>
          <t>Its only argument is an instance of <tt>NodesType</tt> (possibly taken from a
<tt>filter-query</tt>, as in the example above).  The result is an
instance of <tt>ValueType</tt>.</t>
          <ul spacing="normal">
            <li>If the argument contains a single node, the result is
the value of the node.</li>
            <li>If the argument is the special result <tt>Nothing</tt> or contains multiple nodes, the
result is <tt>Nothing</tt>.</li>
          </ul>
          <t>Note: A singular query may be used anywhere where a ValueType is expected,
so there is no need to use the <tt>value()</tt> function extension with a singular query.</t>
        </section>
        <section anchor="examples-6">
          <name>Examples</name>
          <table anchor="tbl-function-expr">
            <name>Function Expression Examples</name>
            <thead>
              <tr>
                <th align="center">Query</th>
                <th align="left">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">
                  <tt>$[?length(@) &lt; 3]</tt></td>
                <td align="left">well-typed</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?length(@.*) &lt; 3]</tt></td>
                <td align="left">not well-typed since <tt>@.*</tt> is a non-singular query</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?count(@.*) == 1]</tt></td>
                <td align="left">well-typed</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?count(1) == 1]</tt></td>
                <td align="left">not well-typed since <tt>1</tt> is not a query or function expression</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?count(foo(@.*)) == 1]</tt></td>
                <td align="left">well-typed, where <tt>foo()</tt> is a function extension with a parameter of type <tt>NodesType</tt> and result type <tt>NodesType</tt></td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?match(@.timezone, 'Europe/.*')]</tt></td>
                <td align="left">well-typed</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?match(@.timezone, 'Europe/.*') == true]</tt></td>
                <td align="left">not well-typed as <tt>LogicalType</tt> may not be used in comparisons</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?value(@..color) == "red"]</tt></td>
                <td align="left">well-typed</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?value(@..color)]</tt></td>
                <td align="left">not well-typed as <tt>ValueType</tt> may not be used in a test expression</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?bar(@.a)]</tt></td>
                <td align="left">well-typed for any function <tt>bar()</tt> with a parameter of any declared type and result type <tt>LogicalType</tt></td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?bnl(@.*)]</tt></td>
                <td align="left">well-typed for any function <tt>bnl()</tt> with a parameter of declared type <tt>NodesType</tt> or <tt>LogicalType</tt> and result type <tt>LogicalType</tt></td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?blt(1==1)]</tt></td>
                <td align="left">well-typed, where <tt>blt()</tt> is a function with a parameter of declared type <tt>LogicalType</tt> and result type <tt>LogicalType</tt></td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?blt(1)]</tt></td>
                <td align="left">not well-typed for the same function <tt>blt()</tt>, as <tt>1</tt> is not a query, <tt>logical-expr</tt>, or function expression</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[?bal(1)]</tt></td>
                <td align="left">well-typed, where <tt>bal()</tt> is a function with a parameter of declared type <tt>ValueType</tt> and result type <tt>LogicalType</tt></td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="segments-details">
        <name>Segments</name>
        <t>For each node in an input nodelist,
segments apply one or more selectors to the node and concatenate the
results of each selector into per-input-node nodelists, which are then
concatenated in the order of the input nodelist to form a single
segment result nodelist.</t>
        <t>It turns out that the more segments there are in a query, the greater the depth in the input value of the
nodes of the resultant nodelist:</t>
        <ul spacing="normal">
          <li>A query with N segments, where N &gt;= 0, produces a nodelist
consisting of nodes at depth in the input value of N or greater.</li>
          <li>A query with N segments, where N &gt;= 0, all of which are <xref target="child-segment">child segments</xref>,
produces a nodelist consisting of nodes precisely at depth N in the input value.</li>
        </ul>
        <t>There are two kinds of segments: child segments and descendant segments.</t>
        <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
segment             = child-segment / descendant-segment
]]></sourcecode>
        <t>The syntax and semantics of each kind of segment are defined below.</t>
        <section anchor="child-segment">
          <name>Child Segment</name>
          <section anchor="syntax-4">
            <name>Syntax</name>
            <t>The child segment consists of a non-empty, comma-separated
sequence of selectors enclosed in square brackets.</t>
            <t>Shorthand notations are also provided for when there is a single
wildcard or name selector.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
child-segment       = bracketed-selection /
                      ("."
                       (wildcard-selector /
                        member-name-shorthand))

bracketed-selection = "[" S selector *(S "," S selector) S "]"

member-name-shorthand = name-first *name-char
name-first          = ALPHA /
                      "_"   /
                      %x80-D7FF /
                         ; skip surrogate code points
                      %xE000-10FFFF
name-char           = name-first / DIGIT

DIGIT               = %x30-39              ; 0-9
ALPHA               = %x41-5A / %x61-7A    ; A-Z / a-z
]]></sourcecode>
            <t><tt>.*</tt>, a <tt>child-segment</tt> directly built from a <tt>wildcard-selector</tt>, is
shorthand for <tt>[*]</tt>.</t>
            <t><tt>.&lt;member-name&gt;</tt>, a <tt>child-segment</tt> built from a
 <tt>member-name-shorthand</tt>, is shorthand for <tt>['&lt;member-name&gt;']</tt>.
Note: This can only be used with member names that are composed of certain
characters, as specified in the ABNF rule <tt>member-name-shorthand</tt>.
Thus, for example, <tt>$.foo.bar</tt> is shorthand for <tt>$['foo']['bar']</tt> (but not for <tt>$['foo.bar']</tt>).</t>
          </section>
          <section anchor="semantics-6">
            <name>Semantics</name>
            <t>A child segment contains a sequence of selectors, each of which
selects zero or more children of the input value.</t>
            <t>Selectors of different kinds may be combined within a single child segment.</t>
            <t>For each node in the input nodelist,
the resulting nodelist of a child segment is the concatenation of
the nodelists from each of its selectors in the order that the selectors
appear in the list.
Note: Any node matched by more than one selector is kept
as many times in the nodelist.</t>
            <t>Where a selector can produce a nodelist in more than one possible order,
each occurrence of the selector in the child segment
	    may produce a nodelist in a distinct order.</t>
	    <t>In summary, a child segment drills down one more level into the structure of the input value.</t>
          </section>
          <section anchor="examples-7">
            <name>Examples</name>
            <t>JSON:</t>
            <sourcecode type="json"><![CDATA[
["a", "b", "c", "d", "e", "f", "g"]
]]></sourcecode>
            <t>Queries:</t>
            <table anchor="tbl-child-segment">
              <name>Child Segment Examples</name>
              <thead>
                <tr>
                  <th align="center">Query</th>
                  <th align="left">Result</th>
                  <th align="center">Result Paths</th>
                  <th align="left">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">
                    <tt>$[0, 3]</tt></td>
                  <td align="left">
                    <tt>"a"</tt> <br/> <tt>"d"</tt></td>
                  <td align="center">
                    <tt>$[0]</tt> <br/> <tt>$[3]</tt></td>
                  <td align="left">Indices</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$[0:2, 5]</tt></td>
                  <td align="left">
                    <tt>"a"</tt> <br/> <tt>"b"</tt> <br/> <tt>"f"</tt></td>
                  <td align="center">
                    <tt>$[0]</tt> <br/> <tt>$[1]</tt> <br/> <tt>$[5]</tt></td>
                  <td align="left">Slice and index</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$[0, 0]</tt></td>
                  <td align="left">
                    <tt>"a"</tt> <br/> <tt>"a"</tt></td>
                  <td align="center">
                    <tt>$[0]</tt> <br/> <tt>$[0]</tt></td>
                  <td align="left">Duplicated entries</td>
                </tr>
              </tbody>
            </table>
          </section>
        </section>
        <section anchor="descendant-segment">
          <name>Descendant Segment</name>
          <section anchor="syntax-5">
            <name>Syntax</name>
            <t>The descendant segment consists of a double dot <tt>..</tt>
followed by a child segment (using bracket notation).</t>
            <t>Shorthand notations are also provided that correspond to the shorthand forms of the child segment.</t>
            <sourcecode type="abnf" name="jsonpath-collected.abnf"><![CDATA[
descendant-segment  = ".." (bracketed-selection /
                            wildcard-selector /
                            member-name-shorthand)
]]></sourcecode>
            <t><tt>..*</tt>, the <tt>descendant-segment</tt> directly built from a
<tt>wildcard-selector</tt>, is shorthand for <tt>..[*]</tt>.</t>
            <t><tt>..&lt;member-name&gt;</tt>, a <tt>descendant-segment</tt> built from a
<tt>member-name-shorthand</tt>, is shorthand for <tt>..['&lt;member-name&gt;']</tt>.
Note: As with the similar shorthand of a <tt>child-segment</tt>, this can
only be used with member names that are composed of certain
characters, as specified in the ABNF rule <tt>member-name-shorthand</tt>.</t>
            <t>Note: On its own, <tt>..</tt> is not a valid segment.</t>
          </section>
          <section anchor="semantics-7">
            <name>Semantics</name>
            <t>A descendant segment produces zero or more descendants of an input value.</t>
            <t>For each node in the input nodelist,
a descendant selector visits the input node and each of
its descendants such that:</t>
            <ul spacing="normal">
              <li>nodes of any array are visited in array order, and</li>
              <li>nodes are visited before their descendants.</li>
            </ul>
            <t>The order in which the children of an object are visited is not stipulated, since
JSON objects are unordered.</t>
            <t>Suppose the descendant segment is of the form <tt>..&wj;[&lt;selectors&gt;]</tt> (after converting any shorthand
form to bracket notation),
and the nodes, in the order visited, are <tt>D1</tt>, ..., <tt>Dn</tt> (where <tt>n &gt;= 1</tt>).
Note: <tt>D1</tt> is the input value.</t>
            <t>For each <tt>i</tt> such that <tt>1 &lt;= i &lt;= n</tt>, the nodelist <tt>Ri</tt> is defined to be a result of applying
the child segment <tt>[&lt;selectors&gt;]</tt> to the node <tt>Di</tt>.</t>
            <t>For each node in the input nodelist,
the result of the descendant segment is the concatenation of <tt>R1</tt>,
..., <tt>Rn</tt> (in that order).
These results are then concatenated in input nodelist order to form
the result of the segment.</t>
	    <t>In summary, a descendant segment drills down one or more levels into the structure of each input value.</t>
          </section>
          <section anchor="examples-8">
            <name>Examples</name>
            <t>JSON:</t>
            <sourcecode type="json"><![CDATA[
{
  "o": {"j": 1, "k": 2},
  "a": [5, 3, [{"j": 4}, {"k": 6}]]
}
]]></sourcecode>
            <t>Queries:</t>
            <t>(Note that the fourth example can be expressed in two equivalent
queries, shown in <xref target="tbl-descendant-segment"/> in one table row instead of two almost-identical rows.)</t>
            <table anchor="tbl-descendant-segment">
              <name>Descendant Segment Examples</name>
              <thead>
                <tr>
                  <th align="center">Query</th>
                  <th align="left">Result</th>
                  <th align="center">Result Paths</th>
                  <th align="left">Comment</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center">
                    <tt>$..j</tt></td>
                  <td align="left">
                    <tt>1</tt> <br/> <tt>4</tt></td>
                  <td align="center">
                    <tt>$['o']['j']</tt> <br/> <tt>$['a'][2][0]['j']</tt></td>
                  <td align="left">Object values</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$..j</tt></td>
                  <td align="left">
                    <tt>4</tt> <br/> <tt>1</tt></td>
                  <td align="center">
                    <tt>$['a'][2][0]['j']</tt> <br/> <tt>$['o']['j']</tt></td>
                  <td align="left">Alternative result</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$..[0]</tt></td>
                  <td align="left">
                    <tt>5</tt> <br/> <tt>{"j": 4}</tt></td>
                  <td align="center">
                    <tt>$['a'][0]</tt> <br/> <tt>$['a'][2][0]</tt></td>
                  <td align="left">Array values</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$..[*]</tt> <br/>or<br/> <tt>$..*</tt></td>
                  <td align="left">
                    <tt>{"j": 1, "k": 2}</tt> <br/> <tt>[5, 3, [{"j": 4}, {"k": 6}]]</tt> <br/> <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>5</tt> <br/> <tt>3</tt> <br/> <tt>[{"j": 4}, {"k": 6}]</tt> <br/> <tt>{"j": 4}</tt> <br/> <tt>{"k": 6}</tt> <br/> <tt>4</tt> <br/> <tt>6</tt></td>
                  <td align="center">
                    <tt>$['o']</tt> <br/> <tt>$['a']</tt> <br/> <tt>$['o']['j']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['a'][0]</tt> <br/> <tt>$['a'][1]</tt> <br/> <tt>$['a'][2]</tt> <br/> <tt>$['a'][2][0]</tt> <br/> <tt>$['a'][2][1]</tt> <br/> <tt>$['a'][2][0]['j']</tt> <br/> <tt>$['a'][2][1]['k']</tt></td>
                  <td align="left">All values</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$..o</tt></td>
                  <td align="left">
                    <tt>{"j": 1, "k": 2}</tt></td>
                  <td align="center">
                    <tt>$['o']</tt></td>
                  <td align="left">Input value is visited</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.o..[*, *]</tt></td>
                  <td align="left">
                    <tt>1</tt> <br/> <tt>2</tt> <br/> <tt>2</tt> <br/> <tt>1</tt></td>
                  <td align="center">
                    <tt>$['o']['j']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['o']['k']</tt> <br/> <tt>$['o']['j']</tt></td>
                  <td align="left">Non-deterministic ordering</td>
                </tr>
                <tr>
                  <td align="center">
                    <tt>$.a..[0, 1]</tt></td>
                  <td align="left">
                    <tt>5</tt> <br/> <tt>3</tt> <br/> <tt>{"j": 4}</tt> <br/> <tt>{"k": 6}</tt></td>
                  <td align="center">
                    <tt>$['a'][0]</tt> <br/> <tt>$['a'][1]</tt> <br/> <tt>$['a'][2][0]</tt> <br/> <tt>$['a'][2][1]</tt></td>
                  <td align="left">Multiple segments</td>
                </tr>
              </tbody>
            </table>
            <t>Note: The ordering of the results for the <tt>$..[*]</tt> and <tt>$..*</tt> examples above is not guaranteed, except that:</t>
            <ul spacing="normal">
              <li>
                <tt>{"j": 1, "k": 2}</tt> must appear before <tt>1</tt> and <tt>2</tt>,</li>
              <li>
                <tt>[5, 3, [{"j": 4}, {"k": 6}]]</tt> must appear before <tt>5</tt>, <tt>3</tt>, and <tt>[{"j": 4}, {"k": 6}]</tt>,</li>
              <li>
                <tt>5</tt> must appear before <tt>3</tt>, which must appear before <tt>[{"j": 4}, {"k": 6}]</tt>,</li>
              <li>
                <tt>5</tt> and <tt>3</tt> must appear before <tt>{"j": 4}</tt>, <tt>4</tt>, <tt>{"k": 6}</tt>, and <tt>6</tt>,</li>
              <li>
                <tt>[{"j": 4}, {"k": 6}]</tt> must appear before <tt>{"j": 4}</tt> and <tt>{"k": 6}</tt>,</li>
              <li>
                <tt>{"j": 4}</tt> must appear before <tt>{"k": 6}</tt>,</li>
              <li>
                <tt>{"k": 6}</tt> must appear before <tt>4</tt>, and</li>
              <li>
                <tt>4</tt> must appear before <tt>6</tt>.</li>
            </ul>
            <t>The example above with the query <tt>$.o..[*, *]</tt> shows that a selector may produce nodelists in distinct orders
each time it appears in the descendant segment.</t>
            <t>The example above with the query <tt>$.a..[0, 1]</tt> shows that the child segment <tt>[0, 1]</tt> is applied to each node
in turn (rather than the nodes being visited once per selector, which is the case for some JSONPath implementations
that do not conform to this specification).</t>
          </section>
        </section>
      </section>
      <section anchor="null-semantics">
        <name>Semantics of <tt>null</tt></name>
        <t>Note: JSON <tt>null</tt> is treated the same as any other JSON value, i.e., it is not taken to mean "undefined" or "missing".</t>
        <section anchor="examples-9">
          <name>Examples</name>
          <t>JSON:</t>
          <sourcecode type="json"><![CDATA[
{"a": null, "b": [null], "c": [{}], "null": 1}
]]></sourcecode>
          <t>Queries:</t>
          <table anchor="tbl-null-examples">
            <name>Examples Involving (or Not Involving) <tt>null</tt></name>
            <thead>
              <tr>
                <th align="center">Query</th>
                <th align="left">Result</th>
                <th align="center">Result Paths</th>
                <th align="left">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">
                  <tt>$.a</tt></td>
                <td align="left">
                  <tt>null</tt></td>
                <td align="center">
                  <tt>$['a']</tt></td>
                <td align="left">Object value</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$.a[0]</tt></td>
                <td align="left"> </td>
                <td align="center"> </td>
                <td align="left">
                  <tt>null</tt> used as array</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$.a.d</tt></td>
                <td align="left"> </td>
                <td align="center"> </td>
                <td align="left">
                  <tt>null</tt> used as object</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$.b[0]</tt></td>
                <td align="left">
                  <tt>null</tt></td>
                <td align="center">
                  <tt>$['b'][0]</tt></td>
                <td align="left">Array value</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$.b[*]</tt></td>
                <td align="left">
                  <tt>null</tt></td>
                <td align="center">
                  <tt>$['b'][0]</tt></td>
                <td align="left">Array value</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$.b[?@]</tt></td>
                <td align="left">
                  <tt>null</tt></td>
                <td align="center">
                  <tt>$['b'][0]</tt></td>
                <td align="left">Existence</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$.b[?@==null]</tt></td>
                <td align="left">
                  <tt>null</tt></td>
                <td align="center">
                  <tt>$['b'][0]</tt></td>
                <td align="left">Comparison</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$.c[?@.d==null]</tt></td>
                <td align="left"> </td>
                <td align="center"> </td>
                <td align="left">Comparison with "missing" value</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$.null</tt></td>
                <td align="left">
                  <tt>1</tt></td>
                <td align="center">
                  <tt>$['null']</tt></td>
                <td align="left">Not JSON <tt>null</tt> at all, just a member name string</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="normalized-paths">
        <name>Normalized Paths</name>
        <t>A Normalized Path is a unique representation of the location of a node in a value that
uniquely identifies the node in the value.
Specifically, a Normalized Path is a JSONPath query with restricted syntax (defined below),
e.g., <tt>$['book'][3]</tt>, which when applied to the value, results in a nodelist consisting
of just the node identified by the Normalized Path.
Note: A Normalized Path represents the identity of a node <em>in a specific value</em>.
There is precisely one Normalized Path identifying any particular node in a value.</t>
        <t>A nodelist may be represented compactly in JSON as an array of strings, where the strings are
Normalized Paths.</t>
        <t>Normalized Paths provide a predictable format that simplifies testing and post-processing
of nodelists, e.g., to remove duplicate nodes.
Normalized Paths are used in this document as result paths in examples.</t>
        <t>Normalized Paths use the canonical bracket notation, rather than dot notation.</t>
        <t>Single quotes are used in Normalized Paths to delimit string member names. This reduces the
number of characters that need escaping when Normalized Paths appear in
strings delimited by double quotes, e.g., in JSON texts.</t>
        <t>Certain characters are escaped in Normalized Paths in one and only one way; all other
	characters are unescaped.</t>
	<aside>
        <t>Note: Normalized Paths are singular queries, but not all singular queries are Normalized Paths.
For example, <tt>$[-3]</tt> is a singular query but is not a Normalized Path.
The Normalized Path equivalent to <tt>$[-3]</tt> would have an index equal to the array length minus <tt>3</tt>.
	(The array length must be at least <tt>3</tt> if <tt>$[-3]</tt> is to identify a node.)</t>
	</aside>
        <sourcecode type="abnf" name="normalized-path-collected.abnf"><![CDATA[
normalized-path      = root-identifier *(normal-index-segment)
normal-index-segment = "[" normal-selector "]"
normal-selector      = normal-name-selector / normal-index-selector
normal-name-selector = %x27 *normal-single-quoted %x27 ; 'string'
normal-single-quoted = normal-unescaped /
                       ESC normal-escapable
normal-unescaped     =    ; omit %x0-1F control codes
                       %x20-26 /
                          ; omit 0x27 '
                       %x28-5B /
                          ; omit 0x5C \
                       %x5D-D7FF /
                          ; skip surrogate code points
                       %xE000-10FFFF

normal-escapable     = %x62 / ; b BS backspace U+0008
                       %x66 / ; f FF form feed U+000C
                       %x6E / ; n LF line feed U+000A
                       %x72 / ; r CR carriage return U+000D
                       %x74 / ; t HT horizontal tab U+0009
                       "'" /  ; ' apostrophe U+0027
                       "\" /  ; \ backslash (reverse solidus) U+005C
                       (%x75 normal-hexchar)
                                       ; certain values u00xx U+00XX
normal-hexchar       = "0" "0"
                       (
                          ("0" %x30-37) / ; "00"-"07"
                             ; omit U+0008-U+000A BS HT LF
                          ("0" %x62) /    ; "0b"
                             ; omit U+000C-U+000D FF CR
                          ("0" %x65-66) / ; "0e"-"0f"
                          ("1" normal-HEXDIG)
                       )
normal-HEXDIG        = DIGIT / %x61-66    ; "0"-"9", "a"-"f"
normal-index-selector = "0" / (DIGIT1 *DIGIT)
                        ; non-negative decimal integer
]]></sourcecode>
        <t>Since there can only be one Normalized Path identifying a given node, the syntax
stipulates which characters are escaped and which are not.
So the definition of <tt>normal-hexchar</tt> is designed for hex escaping of characters
that are not straightforwardly printable, for example, U+000B LINE TABULATION, but
for which no standard JSON escape, such as <tt>\n</tt>, is available.</t>
        <section anchor="examples-10">
          <name>Examples</name>
          <table anchor="tbl-normalized-path-examples">
            <name>Normalized Path Examples</name>
            <thead>
              <tr>
                <th align="center">Path</th>
                <th align="center">Normalized Path</th>
                <th align="left">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">
                  <tt>$.a</tt></td>
                <td align="center">
                  <tt>$['a']</tt></td>
                <td align="left">Object value</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[1]</tt></td>
                <td align="center">
                  <tt>$[1]</tt></td>
                <td align="left">Array index</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$[-3]</tt></td>
                <td align="center">
                  <tt>$[2]</tt></td>
                <td align="left">Negative array index for an array of length 5</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$.a.b[1:2]</tt></td>
                <td align="center">
                  <tt>$['a']['b'][1]</tt></td>
                <td align="left">Nested structure</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$["\u000B"]</tt></td>
                <td align="center">
                  <tt>$['\u000b']</tt></td>
                <td align="left">Unicode escape</td>
              </tr>
              <tr>
                <td align="center">
                  <tt>$["\u0061"]</tt></td>
                <td align="center">
                  <tt>$['a']</tt></td>
                <td align="left">Unicode character</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
    </section>
    <section anchor="IANA">

      <name>IANA Considerations</name>
      <section anchor="registration-of-media-type-applicationjsonpath">
        <name>Registration of Media Type application/jsonpath</name>
        <t>IANA is requested to register the following media type <xref target="RFC6838"/>:</t>
        <dl>
          <dt>Type name:</dt>
          <dd>
            <t>application</t>
          </dd>
          <dt>Subtype name:</dt>
          <dd>
            <t>jsonpath</t>
          </dd>
          <dt>Required parameters:</dt>
          <dd>
            <t>N/A</t>
          </dd>
          <dt>Optional parameters:</dt>
          <dd>
            <t>N/A</t>
          </dd>
          <dt>Encoding considerations:</dt>
          <dd>
            <t>binary (UTF-8)</t>
          </dd>
          <dt>Security considerations:</dt>
          <dd>
            <t>See the Security Considerations section of RFC 9535.</t>
          </dd>
          <dt>Interoperability considerations:</dt>
          <dd>
            <t>N/A</t>
          </dd>
          <dt>Published specification:</dt>
          <dd>
            <t>RFC 9535</t>
          </dd>
          <dt>Applications that use this media type:</dt>
          <dd>
            <t>Applications that need to convey queries in JSON data</t>
          </dd>
          <dt>Fragment identifier considerations:</dt>
          <dd>
            <t>N/A</t>
          </dd>
          <dt>Additional information:</dt>
          <dd><t><br/></t>
            <dl spacing="compact">
              <dt>Deprecated alias names for this type:</dt>
              <dd>
                <t>N/A</t>
              </dd>
              <dt>Magic number(s):</dt>
              <dd>
                <t>N/A</t>
              </dd>
              <dt>File extension(s):</dt>
              <dd>
                <t>N/A</t>
              </dd>
              <dt>Macintosh file type code(s):</dt>
              <dd>
                <t>N/A</t>
              </dd>
            </dl>
          </dd>
        <dt>Person &amp; email address to contact for further information:</dt>
	<dd>iesg@ietf.org</dd>
          <dt>Intended usage:</dt>
          <dd>
            <t>COMMON</t>
          </dd>
          <dt>Restrictions on usage:</dt>
          <dd>
            <t>N/A</t>
          </dd>
          <dt>Author:</dt>
          <dd>
            <t>JSONPath WG</t>
          </dd>
          <dt>Change controller:</dt>
          <dd>
            <t>IETF</t>
          </dd>
        </dl>
      </section>
      <section anchor="iana-fnex">
        <name>Function Extensions Subregistry</name>
        <t>Per this specification, IANA has created a new "Function Extensions" subregistry in
a new "JSONPath" registry. The "Function Extensions" subregistry has the policy "Expert Review"
(<xref section="4.5" sectionFormat="of" target="RFC8126"></xref>).</t>
        <t anchor="de-instructions">The experts are instructed to be frugal in the allocation of function
extension names that are suggestive of generally applicable semantics,
keeping them in reserve for functions that are likely to enjoy wide
use and can make good use of their conciseness.
The expert is also instructed to direct the registrant to provide a
specification (<xref section="4.6" sectionFormat="of" target="RFC8126"></xref>) but can make exceptions,
for instance, when a specification is not available at the time of
registration but is likely forthcoming.
If the expert becomes aware of function extensions that are deployed and
in use, they may also initiate a registration on their own if
they deem such a registration can avert potential future collisions.</t>
        <t>Each entry in the subregistry must include the following:</t>
        <dl newline="true">
          <dt>Function Name:</dt>
          <dd>
            <t>A lowercase ASCII <xref target="RFC0020"/> string that starts with a letter and can
contain letters, digits, and underscore characters afterwards
(<tt>[a-z][_a-z0-9]*</tt>). No other entry in the subregistry can have the
same function name.</t>
          </dd>
          <dt>Brief description:</dt>
          <dd>
            <t>A brief description</t>
          </dd>
          <dt>Parameters:</dt>
          <dd>
            <t>A comma-separated list of zero or more declared types, one for each of the
arguments expected for this function extension</t>
          </dd>
          <dt>Result:</dt>
          <dd>
            <t>The declared type of the result for this function extension</t>
          </dd>
          <dt>Change Controller:</dt>
          <dd>
            <t>See <xref section="2.3" sectionFormat="of" target="RFC8126"></xref>.</t>
          </dd>
          <dt>Reference:</dt>
          <dd>
            <t>A reference document that provides a description of the function
extension</t>
          </dd>
        </dl>
        <t>The initial entries in this subregistry are listed in <xref target="pre-reg"/>; the
entries in the "Change Controller" column all have the value "IETF",
and the entries in the
"Reference" column all have the value "<xref target="fnex"/> of RFC 9535":</t>
<table anchor="pre-reg">
          <name>Initial Entries in the Function Extensions Subregistry</name>
          <thead>
            <tr>
              <th align="left">Function Name</th>
              <th align="left">Brief Description</th>
              <th align="left">Parameters</th>
              <th align="left">Result</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">length</td>
              <td align="left">length of string, array, or object</td>
              <td align="left">
                <tt>ValueType</tt></td>
              <td align="left">
                <tt>ValueType</tt></td>
            </tr>
            <tr>
              <td align="left">count</td>
              <td align="left">size of nodelist</td>
              <td align="left">
                <tt>NodesType</tt></td>
              <td align="left">
                <tt>ValueType</tt></td>
            </tr>
            <tr>
              <td align="left">match</td>
              <td align="left">regular expression full match</td>
              <td align="left">
                <tt>ValueType</tt>, <tt>ValueType</tt></td>
              <td align="left">
                <tt>LogicalType</tt></td>
            </tr>
            <tr>
              <td align="left">search</td>
              <td align="left">regular expression substring match</td>
              <td align="left">
                <tt>ValueType</tt>, <tt>ValueType</tt></td>
              <td align="left">
                <tt>LogicalType</tt></td>
            </tr>
            <tr>
              <td align="left">value</td>
              <td align="left">value of the single node in nodelist</td>
              <td align="left">
                <tt>NodesType</tt></td>
              <td align="left">
                <tt>ValueType</tt></td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="Security">
      <name>Security Considerations</name>
      <t>Security considerations for JSONPath can stem from:</t>
      <ul spacing="normal">
        <li>attack vectors on JSONPath implementations,</li>
        <li>attack vectors on how JSONPath queries are formed, and</li>
        <li>the way JSONPath is used in security-relevant mechanisms.</li>
      </ul>
      <section anchor="attack-vectors-on-jsonpath-implementations">
        <name>Attack Vectors on JSONPath Implementations</name>
        <t>Historically, JSONPath has often been implemented by feeding parts of
the query to an underlying programming language engine, e.g.,
JavaScript's <tt>eval()</tt> function.
This approach is well known to lead to injection attacks and would
require perfect input validation to prevent these attacks (see
<xref section="12" sectionFormat="of" target="RFC8259"/> for similar considerations for JSON itself).
Instead, JSONPath implementations need to implement the entire syntax
of the query without relying on the parsers of programming language
engines.</t>
        <t>Attacks on availability may attempt to trigger unusually expensive
runtime performance exhibited by certain implementations in certain
cases.
(See <xref section="10" sectionFormat="of" target="RFC8949"/> for issues in hash-table implementations
and <xref section="8" sectionFormat="of" target="RFC9485"/> for performance issues in regular
expression implementations.)
Implementers need to be aware that good average performance is not
sufficient as long as an attacker can choose to submit specially
crafted JSONPath queries or query arguments that trigger surprisingly high, possibly
exponential, CPU usage or, for example, via a naive recursive implementation of the descendant segment,
stack overflow. Implementations need to have appropriate resource management
to mitigate these attacks.</t>
      </section>
      <section anchor="attack-vectors-on-how-jsonpath-queries-are-formed">
        <name>Attack Vectors on How JSONPath Queries Are Formed</name>
        <t>JSONPath queries are often not static but formed from variables that
provide index values, member names, or values to compare with in a
filter expression.
These variables need to be validated (e.g., only allowing specific constructs
such as .name to be formed when the given values allow that) and translated
(e.g., by escaping string delimiters).
Not performing these validations and translations correctly can lead to unexpected
failures, which can lead to availability, confidentiality, and
integrity breaches, in particular, if an adversary has control over the
values (e.g., by entering them into a web form).
The resulting class of attacks, <em>injections</em> (e.g., SQL injections),
is consistently found among the top causes of application security
vulnerabilities and requires particular attention.</t>
      </section>
      <section anchor="attacks-on-security-mechanisms-that-employ-jsonpath">
        <name>Attacks on Security Mechanisms That Employ JSONPath</name>
        <t>Where JSONPath is used as a part of a security mechanism, attackers
can attempt to provoke unexpected or unpredictable behavior or
take advantage of differences in behavior between JSONPath implementations.</t>
        <t>Unexpected or unpredictable behavior can arise from a query argument with certain
constructs described as unpredictable by <xref target="RFC8259"/>.
Predictable behavior can be expected, except in relation to the ordering
of objects, for any query argument conforming with <xref target="RFC7493"/>.</t>
        <t>Other attacks can target the behavior of underlying technologies, such as UTF-8 (see
<xref section="10" sectionFormat="of" target="RFC3629"/>) and the Unicode character set.</t>
      </section>
    </section>
  </middle>
  <back>

    <references>
      <name>References</name>
      <references anchor="sec-normative-references">
        <name>Normative References</name>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.0020.xml"/>
  <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3629.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7493.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6838.xml"/>

<!-- [I-D.draft-ietf-jsonpath-iregexp] Published as RFC 9485 -->
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9485.xml"/>

        <reference anchor="UNICODE" target="https://www.unicode.org/versions/latest/">
          <front>
            <title>The Unicode® Standard</title>
            <author>
              <organization>The Unicode Consortium</organization>
            </author>
          </front>
	  <annotation>At the time of writing, <eref target="https://www.unicode.org/versions/Unicode15.0.0/UnicodeStandard-15.0.pdf" brackets="angle"/>.</annotation>
        </reference>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>

      </references>
      <references anchor="sec-informative-references">
        <name>Informative References</name>

        <reference anchor="COMPARISON" target="https://cburgmer.github.io/json-path-comparison/">
          <front>
            <title>JSONPath Comparison</title>
            <author initials="C." surname="Burgmer" fullname="Christoph Burgmer">
              <organization>Thoughtworks</organization>
            </author>
          </front>
        </reference>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6901.xml"/>

        <reference anchor="JSONPath-orig" target="https://goessner.net/articles/JsonPath/">
          <front>
            <title>JSONPath - XPath for JSON</title>
            <author initials="S." surname="Gössner" fullname="Stefan Gössner">
              <organization>Fachhochschule Dortmund</organization>
            </author>
            <date year="2007" month="February"/>
          </front>
        </reference>

        <reference anchor="XPath" target="https://www.w3.org/TR/2010/REC-xpath20-20101214/">
          <front>
            <title>XML Path Language (XPath) 2.0 (Second Edition)</title>
            <author fullname="Anders Berglund" role="editor"/>
            <author fullname="Don Chamberlin" role="editor"/>
            <author fullname="Jerome Simeon" role="editor"/>
            <author fullname="Jonathan Robie" role="editor"/>
            <author fullname="Mary Fernandez" role="editor"/>
            <author fullname="Michael Kay" role="editor"/>
            <author fullname="Scott Boag" role="editor"/>
            <date day="14" month="December" year="2010"/>
          </front>
	  <seriesInfo name="W3C" value="REC-xpath20-20101214"/>
        </reference>

        <reference anchor="E4X" target="https://www.iso.org/standard/41002.html">
          <front>
            <title>Information technology - ECMAScript for XML (E4X) specification</title>
            <author>
              <organization>ISO</organization>
            </author>
            <date year="2006" month="February"/>
          </front>
          <seriesInfo name="ISO/IEC" value="22537:2006"/>
	  <refcontent>Withdrawn</refcontent>
	  <annotation>An equivalent specification, also withdrawn, is available from <eref target="https://ecma-international.org/publications-and-standards/standards/ecma-357" brackets="angle"/>.</annotation>
        </reference>

        <reference anchor="SLICE" target="https://github.com/tc39/proposal-slice-notation">
          <front>
            <title>Slice notation</title>
            <author>
              <organization/>
            </author>
            <date month="July" year="2022"/>
          </front>
	  <refcontent>commit 82f95b4</refcontent>
        </reference>

        <reference anchor="ECMA-262" target="https://www.ecma-international.org/wp-content/uploads/ECMA-262_3rd_edition_december_1999.pdf">
          <front>
            <title>ECMAScript Language Specification</title>
            <author>
              <organization>ECMA International</organization>
            </author>
            <date year="1999" month="December"/>
          </front>
	  <refcontent>Standard ECMA-262, Third Edition</refcontent>
        </reference>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8949.xml"/>

        <reference anchor="BOOLEAN-LAWS" target="https://en.wikipedia.org/w/index.php?title=Boolean_algebra&amp;oldid=1191386550#Laws">
          <front>
            <title>Boolean algebra: Laws</title>
            <author>
              <organization/>
            </author>
            <date month="December" year="2023"/>
          </front>
        </reference>
      </references>
    </references>
<section anchor="collected-abnf-grammars">
      <name>Collected ABNF Grammars</name>
      <t>This appendix collects the ABNF grammar from the ABNF passages used
throughout the document.</t>
      <!-- Update the collected grammar files using `make sourcecode`, which -->
<!-- is currently manual as it creates a little circular dependency. -->
<!-- The filenames of the ::includes are likely to change when -->
<!-- kramdown-rfc-extract-sourcecode handles filenames better. -->

<t><xref target="jsonpath-abnf"/> contains the collected ABNF grammar that defines the
syntax of a JSONPath query.</t>
      <figure anchor="jsonpath-abnf">
        <name>Collected ABNF of JSONPath Queries</name>
        <sourcecode type="abnf"><![CDATA[
jsonpath-query      = root-identifier segments
segments            = *(S segment)

B                   = %x20 /    ; Space
                      %x09 /    ; Horizontal tab
                      %x0A /    ; Line feed or New line
                      %x0D      ; Carriage return
S                   = *B        ; optional blank space
root-identifier     = "$"
selector            = name-selector /
                      wildcard-selector /
                      slice-selector /
                      index-selector /
                      filter-selector
name-selector       = string-literal

string-literal      = %x22 *double-quoted %x22 /     ; "string"
                      %x27 *single-quoted %x27       ; 'string'

double-quoted       = unescaped /
                      %x27      /                    ; '
                      ESC %x22  /                    ; \"
                      ESC escapable

single-quoted       = unescaped /
                      %x22      /                    ; "
                      ESC %x27  /                    ; \'
                      ESC escapable

ESC                 = %x5C                           ; \ backslash

unescaped           = %x20-21 /                      ; see RFC 8259
                         ; omit 0x22 "
                      %x23-26 /
                         ; omit 0x27 '
                      %x28-5B /
                         ; omit 0x5C \
                      %x5D-D7FF /
                         ; skip surrogate code points
                      %xE000-10FFFF

escapable           = %x62 / ; b BS backspace U+0008
                      %x66 / ; f FF form feed U+000C
                      %x6E / ; n LF line feed U+000A
                      %x72 / ; r CR carriage return U+000D
                      %x74 / ; t HT horizontal tab U+0009
                      "/"  / ; / slash (solidus) U+002F
                      "\"  / ; \ backslash (reverse solidus) U+005C
                      (%x75 hexchar) ;  uXXXX U+XXXX

hexchar             = non-surrogate /
                      (high-surrogate "\" %x75 low-surrogate)
non-surrogate       = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG) /
                      ("D" %x30-37 2HEXDIG )
high-surrogate      = "D" ("8"/"9"/"A"/"B") 2HEXDIG
low-surrogate       = "D" ("C"/"D"/"E"/"F") 2HEXDIG

HEXDIG              = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
wildcard-selector   = "*"
index-selector      = int                        ; decimal integer

int                 = "0" /
                      (["-"] DIGIT1 *DIGIT)      ; - optional
DIGIT1              = %x31-39                    ; 1-9 non-zero digit
slice-selector      = [start S] ":" S [end S] [":" [S step ]]

start               = int       ; included in selection
end                 = int       ; not included in selection
step                = int       ; default: 1
filter-selector     = "?" S logical-expr
logical-expr        = logical-or-expr
logical-or-expr     = logical-and-expr *(S "||" S logical-and-expr)
                        ; disjunction
                        ; binds less tightly than conjunction
logical-and-expr    = basic-expr *(S "&&" S basic-expr)
                        ; conjunction
                        ; binds more tightly than disjunction

basic-expr          = paren-expr /
                      comparison-expr /
                      test-expr

paren-expr          = [logical-not-op S] "(" S logical-expr S ")"
                                        ; parenthesized expression
logical-not-op      = "!"               ; logical NOT operator
test-expr           = [logical-not-op S]
                      (filter-query / ; existence/non-existence
                       function-expr) ; LogicalType or NodesType
filter-query        = rel-query / jsonpath-query
rel-query           = current-node-identifier segments
current-node-identifier = "@"
comparison-expr     = comparable S comparison-op S comparable
literal             = number / string-literal /
                      true / false / null
comparable          = literal /
                      singular-query / ; singular query value
                      function-expr    ; ValueType
comparison-op       = "==" / "!=" /
                      "<=" / ">=" /
                      "<"  / ">"

singular-query      = rel-singular-query / abs-singular-query
rel-singular-query  = current-node-identifier singular-query-segments
abs-singular-query  = root-identifier singular-query-segments
singular-query-segments = *(S (name-segment / index-segment))
name-segment        = ("[" name-selector "]") /
                      ("." member-name-shorthand)
index-segment       = "[" index-selector "]"
number              = (int / "-0") [ frac ] [ exp ] ; decimal number
frac                = "." 1*DIGIT                  ; decimal fraction
exp                 = "e" [ "-" / "+" ] 1*DIGIT    ; decimal exponent
true                = %x74.72.75.65                ; true
false               = %x66.61.6c.73.65             ; false
null                = %x6e.75.6c.6c                ; null
function-name       = function-name-first *function-name-char
function-name-first = LCALPHA
function-name-char  = function-name-first / "_" / DIGIT
LCALPHA             = %x61-7A  ; "a".."z"

function-expr       = function-name "(" S [function-argument
                         *(S "," S function-argument)] S ")"
function-argument   = literal /
                      filter-query / ; (includes singular-query)
                      logical-expr /
                      function-expr
segment             = child-segment / descendant-segment
child-segment       = bracketed-selection /
                      ("."
                       (wildcard-selector /
                        member-name-shorthand))

bracketed-selection = "[" S selector *(S "," S selector) S "]"

member-name-shorthand = name-first *name-char
name-first          = ALPHA /
                      "_"   /
                      %x80-D7FF /
                         ; skip surrogate code points
                      %xE000-10FFFF
name-char           = name-first / DIGIT

DIGIT               = %x30-39              ; 0-9
ALPHA               = %x41-5A / %x61-7A    ; A-Z / a-z
descendant-segment  = ".." (bracketed-selection /
                            wildcard-selector /
                            member-name-shorthand)
]]></sourcecode>
      </figure>
      <t><xref target="normalized-path-abnf"/> contains the collected ABNF grammar that
defines the syntax of a JSONPath Normalized Path while also using the rules
<tt>root-identifier</tt>, <tt>ESC</tt>, <tt>DIGIT</tt>, and <tt>DIGIT1</tt> from <xref target="jsonpath-abnf"/>.</t>
      <figure anchor="normalized-path-abnf">
        <name>Collected ABNF of JSONPath Normalized Paths</name>
        <sourcecode type="abnf"><![CDATA[
normalized-path      = root-identifier *(normal-index-segment)
normal-index-segment = "[" normal-selector "]"
normal-selector      = normal-name-selector / normal-index-selector
normal-name-selector = %x27 *normal-single-quoted %x27 ; 'string'
normal-single-quoted = normal-unescaped /
                       ESC normal-escapable
normal-unescaped     =    ; omit %x0-1F control codes
                       %x20-26 /
                          ; omit 0x27 '
                       %x28-5B /
                          ; omit 0x5C \
                       %x5D-D7FF /
                          ; skip surrogate code points
                       %xE000-10FFFF

normal-escapable     = %x62 / ; b BS backspace U+0008
                       %x66 / ; f FF form feed U+000C
                       %x6E / ; n LF line feed U+000A
                       %x72 / ; r CR carriage return U+000D
                       %x74 / ; t HT horizontal tab U+0009
                       "'" /  ; ' apostrophe U+0027
                       "\" /  ; \ backslash (reverse solidus) U+005C
                       (%x75 normal-hexchar)
                                       ; certain values u00xx U+00XX
normal-hexchar       = "0" "0"
                       (
                          ("0" %x30-37) / ; "00"-"07"
                             ; omit U+0008-U+000A BS HT LF
                          ("0" %x62) /    ; "0b"
                             ; omit U+000C-U+000D FF CR
                          ("0" %x65-66) / ; "0e"-"0f"
                          ("1" normal-HEXDIG)
                       )
normal-HEXDIG        = DIGIT / %x61-66    ; "0"-"9", "a"-"f"
normal-index-selector = "0" / (DIGIT1 *DIGIT)
                        ; non-negative decimal integer
]]></sourcecode>
      </figure>
    </section>
    <section anchor="inspired-by-xpath">
      <name>Inspired by XPath</name>
      <t>This appendix is informative.</t>
      <t>At the time JSONPath was invented, XML was noted for the availability of
powerful tools to analyze, transform, and selectively extract data from
XML documents.
<xref target="XPath"/> is one of these tools.</t>
      <t>In 2007, the need for something solving the same class of problems for
the emerging JSON community became apparent, specifically for:</t>
      <ul spacing="normal">
        <li>finding data interactively and extracting them out of
JSON values <xref target="RFC8259"/> without special scripting and</li>
        <li>specifying the relevant parts of the JSON data in a request by a
client, so the server can reduce the amount of data in its response,
minimizing bandwidth usage.</li>
      </ul>
      <t>(Note: XPath has evolved since 2007, and recent versions even
nominally support operating inside JSON values.
This appendix only discusses the more widely used version of XPath
that was available in 2007.)</t>
      <t>JSONPath picks up the overall feeling of XPath but maps the concepts
to syntax (and partially semantics) that would be familiar to someone
using JSON in a dynamic language.</t>
      <t>For example, in popular dynamic programming languages such as JavaScript,
Python, and PHP, the semantics of the XPath expression:</t>
      <sourcecode type="xpath"><![CDATA[
/store/book[1]/title
]]></sourcecode>
      <t>can be realized in the expression:</t>
      <sourcecode type="xpath"><![CDATA[
x.store.book[0].title
]]></sourcecode>
      <t>or in bracket notation:</t>
      <sourcecode type="xpath"><![CDATA[
x['store']['book'][0]['title']
]]></sourcecode>
      <t>with the variable x holding the query argument.</t>
      <t>The JSONPath language was designed to:</t>
      <ul spacing="normal">
        <li>be naturally based on those language characteristics,</li>
        <li>cover only the most essential parts of XPath 1.0,</li>
        <li>be lightweight in code size and memory consumption, and</li>
        <li>be runtime efficient.</li>
      </ul>
      <section anchor="xpath-overview">
        <name>JSONPath and XPath</name>
        <t>JSONPath expressions apply to JSON values in the same way
as XPath expressions are used in combination with an XML document.
JSONPath uses <tt>$</tt> to refer to the root node of the query argument, similar
to XPath's <tt>/</tt> at the front.</t>
<t>JSONPath expressions move further down the hierarchy using <em>dot notation</em>
(<tt>$.store.book[0].title</tt>)
or the <em>bracket notation</em>
(<tt>$['store']['book'][0]['title']</tt>); both replace XPath's <tt>/</tt> within query expressions, where <em>dot notation</em> serves as a lightweight but limited syntax while <em>bracket notation</em> is a
heavyweight but more general syntax.</t>
        <t>Both JSONPath and XPath use <tt>*</tt> for a wildcard.
JSONPath's descendant segment notation, starting with <tt>..</tt>, borrowed from <xref target="E4X"/>, is similar to XPath's <tt>//</tt>.
The array slicing construct <tt>[start:end:step]</tt> is unique to JSONPath,
inspired by <xref target="SLICE"/> from ECMASCRIPT 4.</t>
        <t>Filter expressions are supported via the syntax <tt>?&lt;logical-expr&gt;</tt> as in:</t>
        <sourcecode type="application/jsonpath"><![CDATA[
$.store.book[?@.price < 10].title
]]></sourcecode>
        <t><xref target="tbl-xpath-overview"/> extends <xref target="tbl-overview"/> by providing a comparison
with similar XPath concepts.</t>
        <table anchor="tbl-xpath-overview">
          <name>XPath Syntax Compared to JSONPath</name>
          <thead>
            <tr>
              <th align="left">XPath</th>
              <th align="left">JSONPath</th>
              <th align="left">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">
                <tt>/</tt></td>
              <td align="left">
                <tt>$</tt></td>
              <td align="left">the root XML element</td>
            </tr>
            <tr>
              <td align="left">
                <tt>.</tt></td>
              <td align="left">
                <tt>@</tt></td>
              <td align="left">the current XML element</td>
            </tr>
            <tr>
              <td align="left">
                <tt>/</tt></td>
              <td align="left">
                <tt>.</tt> or <tt>[]</tt></td>
              <td align="left">child operator</td>
            </tr>
            <tr>
              <td align="left">
                <tt>..</tt></td>
              <td align="left">n/a</td>
              <td align="left">parent operator</td>
            </tr>
            <tr>
              <td align="left">
                <tt>//</tt></td>
              <td align="left">
                <tt>..name</tt>, <tt>..[index]</tt>, <tt>..*</tt>, or <tt>..[*]</tt></td>
              <td align="left">descendants (JSONPath borrows this syntax from E4X)</td>
            </tr>
            <tr>
              <td align="left">
                <tt>*</tt></td>
              <td align="left">
                <tt>*</tt></td>
              <td align="left">wildcard: All XML elements regardless of their names</td>
            </tr>
            <tr>
              <td align="left">
                <tt>@</tt></td>
              <td align="left">n/a</td>
              <td align="left">attribute access: JSON values do not have attributes</td>
            </tr>
            <tr>
              <td align="left">
                <tt>[]</tt></td>
              <td align="left">
                <tt>[]</tt></td>
              <td align="left">subscript operator used to iterate over XML element collections and for predicates</td>
            </tr>
            <tr>
              <td align="left">
                <tt>|</tt></td>
              <td align="left">
                <tt>[,]</tt></td>
              <td align="left">Union operator (results in a combination of node sets); called list operator in JSONPath, allows combining member names, array indices, and slices</td>
            </tr>
            <tr>
              <td align="left">n/a</td>
              <td align="left">
                <tt>[start:end:step]</tt></td>
              <td align="left">array slice operator borrowed from ES4</td>
            </tr>
            <tr>
              <td align="left">
                <tt>[]</tt></td>
              <td align="left">
                <tt>?</tt></td>
              <td align="left">applies a filter (script) expression</td>
            </tr>
            <tr>
              <td align="left">seamless</td>
              <td align="left">n/a</td>
              <td align="left">expression engine</td>
            </tr>
            <tr>
              <td align="left">
                <tt>()</tt></td>
              <td align="left">n/a</td>
              <td align="left">grouping</td>
            </tr>
          </tbody>
        </table>
<t>For further illustration, <xref target="tbl-xpath-equivalents"/> shows some XPath expressions
and their JSONPath equivalents.</t>
        <table anchor="tbl-xpath-equivalents">
          <name>Example XPath Expressions and Their JSONPath Equivalents</name>
          <thead>
            <tr>
              <th align="left">XPath</th>
              <th align="left">JSONPath</th>
              <th align="left">Result</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">
                <tt>/store/book/author</tt></td>
              <td align="left">
                <tt>$.store.book[*].author</tt></td>
              <td align="left">the authors of all books in the store</td>
            </tr>
            <tr>
              <td align="left">
                <tt>//author</tt></td>
              <td align="left">
                <tt>$..author</tt></td>
              <td align="left">all authors</td>
            </tr>
            <tr>
              <td align="left">
                <tt>/store/*</tt></td>
              <td align="left">
                <tt>$.store.*</tt></td>
              <td align="left">all things in store, which are some books and a red bicycle</td>
            </tr>
            <tr>
              <td align="left">
                <tt>/store//price</tt></td>
              <td align="left">
                <tt>$.store..price</tt></td>
              <td align="left">the prices of everything in the store</td>
            </tr>
            <tr>
              <td align="left">
                <tt>//book[3]</tt></td>
              <td align="left">
                <tt>$..book[2]</tt></td>
              <td align="left">the third book</td>
            </tr>
            <tr>
              <td align="left">
                <tt>//book[last()]</tt></td>
              <td align="left">
                <tt>$..book[-1]</tt></td>
              <td align="left">the last book in order</td>
            </tr>
            <tr>
              <td align="left">
                <tt>//book[position()&lt;3]</tt></td>
              <td align="left">
                <tt>$..book[0,1]</tt><br/><tt>$..book[:2]</tt></td>
              <td align="left">the first two books</td>
            </tr>
            <tr>
              <td align="left">
                <tt>//book[isbn]</tt></td>
              <td align="left">
                <tt>$..book[?@.isbn]</tt></td>
              <td align="left">filter all books with an ISBN number</td>
            </tr>
            <tr>
              <td align="left">
                <tt>//book[price&lt;10]</tt></td>
              <td align="left">
                <tt>$..book[?@.price&lt;10]</tt></td>
              <td align="left">filter all books cheaper than 10</td>
            </tr>
            <tr>
              <td align="left">
                <tt>//*</tt></td>
              <td align="left">
                <tt>$..*</tt></td>
              <td align="left">all elements in an XML document; all member values and array elements contained in input value</td>
            </tr>
          </tbody>
        </table>
        <t>XPath has a lot more functionality (location paths in unabbreviated syntax,
operators, and functions) than listed in this comparison.  Moreover, there are
significant differences in how the subscript operator works in XPath and
JSONPath:</t>
        <ul spacing="normal">
          <li>Square brackets in XPath expressions always operate on the <em>node
set</em> resulting from the previous path fragment. Indices always start
at 1.</li>
          <li>With JSONPath, square brackets operate on each of the nodes in the <em>nodelist</em>
resulting from the previous query segment. Array indices always start
at 0.</li>
        </ul>
      </section>
    </section>
    <section anchor="json-pointer">
      <name>JSON Pointer</name>
      <t>This appendix is informative.</t>
      <t>In relation to JSON Pointer <xref target="RFC6901"/>, JSONPath is not intended as a replacement but as a more powerful
companion. The purposes of the two standards
are different.</t>
      <t>JSON Pointer is for identifying a single value within a JSON value whose
structure is known.</t>
      <t>JSONPath can identify a single value within a JSON value, for example, by
using a Normalized Path. But JSONPath is also a query syntax that can be used
to search for and extract multiple values from JSON values whose structure
is known only in a general way.</t>
      <t>A Normalized JSONPath can be converted into a JSON Pointer by converting the syntax,
without knowledge of any JSON value. The inverse is not generally true, i.e., a numeric
reference token (path component) in a JSON Pointer may identify a member value of an object or an element of an array.
For conversion to a JSONPath query, knowledge of the structure of the JSON value is
needed to distinguish these cases.</t>
    </section>
    <section numbered="false" anchor="acknowledgements">
      <name>Acknowledgements</name>
      <t>This document is based on <contact fullname="Stefan Gössner"/>'s
original online article defining JSONPath <xref target="JSONPath-orig"/>.</t>
<t>The books example was taken from course material that Bielefeld University, Germany used in 2002.</t>
      <t>This work is indebted to <contact fullname="Christoph Burgmer"/> for the superb
JSONPath comparison project <xref target="COMPARISON"/> that details the behavior of over forty JSONPath
implementations applied to numerous queries.</t>
</section>
    <section anchor="contributors" numbered="false" toc="include">
      <name>Contributors</name>
      <contact initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
        <organization>InfluxData, Inc.</organization>
        <address>
          <postal>
            <city>Pisa</city>
            <country>Italy</country>
          </postal>
          <email>mmikulicic@gmail.com</email>
        </address>
      </contact>
      <contact initials="E." surname="Surov" fullname="Edward Surov">
        <organization>TheSoul Publishing Ltd.</organization>
        <address>
          <postal>
            <city>Limassol</city>
            <country>Cyprus</country>
          </postal>
          <email>esurov.tsp@gmail.com</email>
        </address>
      </contact>
      <contact initials="G." surname="Dennis" fullname="Greg Dennis">
        <organization/>
        <address>
          <postal>
            <city>Auckland</city>
            <country>New Zealand</country>
          </postal>
          <email>gregsdennis@yahoo.com</email>
          <uri>https://github.com/gregsdennis</uri>
        </address>
      </contact>
    </section>
  </back>
</rfc>
